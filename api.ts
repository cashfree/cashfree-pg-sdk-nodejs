/* tslint:disable */
/* eslint-disable */
/**
 * Cashfree Payment Gateway APIs
 * Cashfree\'s Payment Gateway APIs provide developers with a streamlined pathway to integrate advanced payment processing capabilities into their applications, platforms and websites.
 *
 * The version of the OpenAPI document: 2023-08-01
 * Contact: developers@cashfree.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';
import { CFEnvironment } from './configuration'
import * as Sentry from "@sentry/node";
import * as crypto from "crypto";

/**
 * Adjust Vendor Balance Request
 * @export
 * @interface AdjustVendorBalanceRequest
 */
export interface AdjustVendorBalanceRequest {
    /**
     * Mention to whom you want to transfer the on demand balance. Possible values - MERCHANT, VENDOR.
     * @type {string}
     * @memberof AdjustVendorBalanceRequest
     */
    'transfer_from': string;
    /**
     * Mention the type of transfer. Possible values: ON_DEMAND.
     * @type {string}
     * @memberof AdjustVendorBalanceRequest
     */
    'transfer_type': string;
    /**
     * Mention the on demand transfer amount.
     * @type {number}
     * @memberof AdjustVendorBalanceRequest
     */
    'transfer_amount': number;
    /**
     * Mention remarks if any for the on demand transfer.
     * @type {string}
     * @memberof AdjustVendorBalanceRequest
     */
    'remark'?: string;
    /**
     * Provide additional data fields using tags.
     * @type {object}
     * @memberof AdjustVendorBalanceRequest
     */
    'tags'?: object;
}
/**
 * Adjust Vendor Balance Response
 * @export
 * @interface AdjustVendorBalanceResponse
 */
export interface AdjustVendorBalanceResponse {
    /**
     * 
     * @type {number}
     * @memberof AdjustVendorBalanceResponse
     */
    'settlement_id'?: number;
    /**
     * 
     * @type {TransferDetails}
     * @memberof AdjustVendorBalanceResponse
     */
    'transfer_details'?: TransferDetails;
    /**
     * 
     * @type {BalanceDetails}
     * @memberof AdjustVendorBalanceResponse
     */
    'balances'?: BalanceDetails;
    /**
     * 
     * @type {ChargesDetails}
     * @memberof AdjustVendorBalanceResponse
     */
    'charges'?: ChargesDetails;
}
/**
 * Error at cashfree\'s server
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'code'?: string;
    /**
     * api_error
     * @type {string}
     * @memberof ApiError
     */
    'type'?: ApiErrorTypeEnum;
}

export const ApiErrorTypeEnum = {
    API_ERROR: 'api_error',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type ApiErrorTypeEnum = typeof ApiErrorTypeEnum[keyof typeof ApiErrorTypeEnum];

/**
 * Error when resource requested is not found
 * @export
 * @interface ApiError404
 */
export interface ApiError404 {
    /**
     * 
     * @type {string}
     * @memberof ApiError404
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError404
     */
    'code'?: string;
    /**
     * invalid_request_error
     * @type {string}
     * @memberof ApiError404
     */
    'type'?: ApiError404TypeEnum;
}

export const ApiError404TypeEnum = {
    INVALID_REQUEST_ERROR: 'invalid_request_error',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type ApiError404TypeEnum = typeof ApiError404TypeEnum[keyof typeof ApiError404TypeEnum];

/**
 * duplicate request
 * @export
 * @interface ApiError409
 */
export interface ApiError409 {
    /**
     * 
     * @type {string}
     * @memberof ApiError409
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError409
     */
    'code'?: string;
    /**
     * invalid_request_error
     * @type {string}
     * @memberof ApiError409
     */
    'type'?: ApiError409TypeEnum;
}

export const ApiError409TypeEnum = {
    INVALID_REQUEST_ERROR: 'invalid_request_error',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type ApiError409TypeEnum = typeof ApiError409TypeEnum[keyof typeof ApiError409TypeEnum];

/**
 * Error when there is error at partner bank
 * @export
 * @interface ApiError502
 */
export interface ApiError502 {
    /**
     * 
     * @type {string}
     * @memberof ApiError502
     */
    'message'?: string;
    /**
     * `bank_processing_failure` will be returned here to denote failure at bank. 
     * @type {string}
     * @memberof ApiError502
     */
    'code'?: string;
    /**
     * api_error
     * @type {string}
     * @memberof ApiError502
     */
    'type'?: ApiError502TypeEnum;
}

export const ApiError502TypeEnum = {
    API_ERROR: 'api_error',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type ApiError502TypeEnum = typeof ApiError502TypeEnum[keyof typeof ApiError502TypeEnum];

/**
 * App payment method
 * @export
 * @interface App
 */
export interface App {
    /**
     * Specify the channel through which the payment must be processed.
     * @type {string}
     * @memberof App
     */
    'channel': string;
    /**
     * Specify the provider through which the payment must be processed.
     * @type {string}
     * @memberof App
     */
    'provider': AppProviderEnum;
    /**
     * Customer phone number associated with a wallet for payment.
     * @type {string}
     * @memberof App
     */
    'phone': string;
}

export const AppProviderEnum = {
    GPAY: 'gpay',
    PHONEPE: 'phonepe',
    OLA: 'ola',
    PAYTM: 'paytm',
    AMAZON: 'amazon',
    AIRTEL: 'airtel',
    FREECHARGE: 'freecharge',
    MOBIKWIK: 'mobikwik',
    JIO: 'jio',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type AppProviderEnum = typeof AppProviderEnum[keyof typeof AppProviderEnum];

/**
 * App payment method
 * @export
 * @interface AppPaymentMethod
 */
export interface AppPaymentMethod {
    /**
     * 
     * @type {App}
     * @memberof AppPaymentMethod
     */
    'app': App;
}
/**
 * Error if api keys are wrong
 * @export
 * @interface AuthenticationError
 */
export interface AuthenticationError {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationError
     */
    'code'?: string;
    /**
     * authentication_error
     * @type {string}
     * @memberof AuthenticationError
     */
    'type'?: string;
}
/**
 * If preauth enabled for account you will get this body
 * @export
 * @interface AuthorizationInPaymentsEntity
 */
export interface AuthorizationInPaymentsEntity {
    /**
     * One of CAPTURE or VOID
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'action'?: AuthorizationInPaymentsEntityActionEnum;
    /**
     * One of SUCCESS or PENDING
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'status'?: AuthorizationInPaymentsEntityStatusEnum;
    /**
     * The captured amount for this authorization request
     * @type {number}
     * @memberof AuthorizationInPaymentsEntity
     */
    'captured_amount'?: number;
    /**
     * Start time of this authorization hold (only for UPI)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'start_time'?: string;
    /**
     * End time of this authorization hold (only for UPI)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'end_time'?: string;
    /**
     * Approve by time as passed in the authorization request (only for UPI)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'approve_by'?: string;
    /**
     * CAPTURE or VOID reference number based on action 
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'action_reference'?: string;
    /**
     * Time of action (CAPTURE or VOID)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'action_time'?: string;
}

export const AuthorizationInPaymentsEntityActionEnum = {
    CAPTURE: 'CAPTURE',
    VOID: 'VOID',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type AuthorizationInPaymentsEntityActionEnum = typeof AuthorizationInPaymentsEntityActionEnum[keyof typeof AuthorizationInPaymentsEntityActionEnum];
export const AuthorizationInPaymentsEntityStatusEnum = {
    SUCCESS: 'SUCCESS',
    PENDING: 'PENDING',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type AuthorizationInPaymentsEntityStatusEnum = typeof AuthorizationInPaymentsEntityStatusEnum[keyof typeof AuthorizationInPaymentsEntityStatusEnum];

/**
 * Request to capture or void transaction
 * @export
 * @interface AuthorizeOrderRequest
 */
export interface AuthorizeOrderRequest {
    /**
     * Type of authorization to run. Can be one of \'CAPTURE\' , \'VOID\'
     * @type {string}
     * @memberof AuthorizeOrderRequest
     */
    'action'?: AuthorizeOrderRequestActionEnum;
    /**
     * The amount if you are running a \'CAPTURE\'
     * @type {number}
     * @memberof AuthorizeOrderRequest
     */
    'amount'?: number;
}

export const AuthorizeOrderRequestActionEnum = {
    CAPTURE: 'CAPTURE',
    VOID: 'VOID',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type AuthorizeOrderRequestActionEnum = typeof AuthorizeOrderRequestActionEnum[keyof typeof AuthorizeOrderRequestActionEnum];

/**
 * Invalid request received from client
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     * 
     * @type {string}
     * @memberof BadRequestError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BadRequestError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BadRequestError
     */
    'type'?: BadRequestErrorTypeEnum;
}

export const BadRequestErrorTypeEnum = {
    INVALID_REQUEST_ERROR: 'invalid_request_error',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type BadRequestErrorTypeEnum = typeof BadRequestErrorTypeEnum[keyof typeof BadRequestErrorTypeEnum];

/**
 * 
 * @export
 * @interface BalanceDetails
 */
export interface BalanceDetails {
    /**
     * 
     * @type {number}
     * @memberof BalanceDetails
     */
    'merchant_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceDetails
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof BalanceDetails
     */
    'merchant_unsettled'?: number;
    /**
     * 
     * @type {number}
     * @memberof BalanceDetails
     */
    'vendor_unsettled'?: number;
}
/**
 * 
 * @export
 * @interface BankDetails
 */
export interface BankDetails {
    /**
     * 
     * @type {string}
     * @memberof BankDetails
     */
    'account_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDetails
     */
    'account_holder'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDetails
     */
    'ifsc'?: string;
}
/**
 * Banktransfer payment method
 * @export
 * @interface Banktransfer
 */
export interface Banktransfer {
    /**
     * The channel for cardless EMI is always `link`
     * @type {string}
     * @memberof Banktransfer
     */
    'channel'?: string;
}
/**
 * banktransfer payment method
 * @export
 * @interface BanktransferPaymentMethod
 */
export interface BanktransferPaymentMethod {
    /**
     * 
     * @type {Banktransfer}
     * @memberof BanktransferPaymentMethod
     */
    'banktransfer': Banktransfer;
}
/**
 * Card Payment method
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * The channel for card payments can be \"link\" or \"post\". Post is used for seamless OTP payments where merchant captures OTP on their own page.
     * @type {string}
     * @memberof Card
     */
    'channel': CardChannelEnum;
    /**
     * Customer card number for plain card transactions. Token pan number for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_number'?: string;
    /**
     * Customer name mentioned on the card.
     * @type {string}
     * @memberof Card
     */
    'card_holder_name'?: string;
    /**
     * Card expiry month for plain card transactions. Token expiry month for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_expiry_mm'?: string;
    /**
     * Card expiry year for plain card transactions. Token expiry year for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_expiry_yy'?: string;
    /**
     * CVV mentioned on the card.
     * @type {string}
     * @memberof Card
     */
    'card_cvv'?: string;
    /**
     * instrument id of saved card. Required only to make payment using saved instrument.
     * @type {string}
     * @memberof Card
     */
    'instrument_id'?: string;
    /**
     * cryptogram received from card network. Required only for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'cryptogram'?: string;
    /**
     * TRID issued by card networks. Required only for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'token_requestor_id'?: string;
    /**
     * Token Reference Id provided by Diners for Guest Checkout Token.  Required only for Diners cards. 
     * @type {string}
     * @memberof Card
     */
    'token_reference_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'token_type'?: CardTokenTypeEnum;
    /**
     * last 4 digits of original card number. Required only for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_display'?: string;
    /**
     * Card alias as returned by Cashfree Vault API.
     * @type {string}
     * @memberof Card
     */
    'card_alias'?: string;
    /**
     * One of [\"Kotak\", \"ICICI\", \"RBL\", \"BOB\", \"Standard Chartered\"]. Card bank name, required for EMI payments. This is the bank user has selected for EMI
     * @type {string}
     * @memberof Card
     */
    'card_bank_name'?: CardCardBankNameEnum;
    /**
     * EMI tenure selected by the user
     * @type {number}
     * @memberof Card
     */
    'emi_tenure'?: number;
}

export const CardChannelEnum = {
    LINK: 'link',
    POST: 'post',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type CardChannelEnum = typeof CardChannelEnum[keyof typeof CardChannelEnum];
export const CardTokenTypeEnum = {
    ISSUER_TOKEN: 'ISSUER_TOKEN',
    NETWORK_GC_TOKEN: 'NETWORK_GC_TOKEN',
    ISSUER_GC_TOKEN: 'ISSUER_GC_TOKEN',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type CardTokenTypeEnum = typeof CardTokenTypeEnum[keyof typeof CardTokenTypeEnum];
export const CardCardBankNameEnum = {
    KOTAK: 'Kotak',
    ICICI: 'ICICI',
    RBL: 'RBL',
    BOB: 'BOB',
    STANDARD_CHARTERED: 'Standard Chartered',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type CardCardBankNameEnum = typeof CardCardBankNameEnum[keyof typeof CardCardBankNameEnum];

/**
 * Payment method for card emi
 * @export
 * @interface CardEMI
 */
export interface CardEMI {
    /**
     * The channel for card payments will always be \"link\"
     * @type {string}
     * @memberof CardEMI
     */
    'channel': string;
    /**
     * Customer card number.
     * @type {string}
     * @memberof CardEMI
     */
    'card_number': string;
    /**
     * Customer name mentioned on the card.
     * @type {string}
     * @memberof CardEMI
     */
    'card_holder_name'?: string;
    /**
     * Card expiry month.
     * @type {string}
     * @memberof CardEMI
     */
    'card_expiry_mm': string;
    /**
     * Card expiry year.
     * @type {string}
     * @memberof CardEMI
     */
    'card_expiry_yy': string;
    /**
     * CVV mentioned on the card.
     * @type {string}
     * @memberof CardEMI
     */
    'card_cvv': string;
    /**
     * Card alias as returned by Cashfree Vault API
     * @type {string}
     * @memberof CardEMI
     */
    'card_alias'?: string;
    /**
     * Card bank name, required for EMI payments. This is the bank user has selected for EMI. One of [\"hdfc, \"kotak\", \"icici\", \"rbl\", \"bob\", \"standard chartered\", \"axis\", \"au\", \"yes\", \"sbi\", \"fed\", \"hsbc\", \"citi\", \"amex\"]
     * @type {string}
     * @memberof CardEMI
     */
    'card_bank_name': CardEMICardBankNameEnum;
    /**
     * EMI tenure selected by the user
     * @type {number}
     * @memberof CardEMI
     */
    'emi_tenure': number;
}

export const CardEMICardBankNameEnum = {
    HDFC: 'hdfc',
    KOTAK: 'kotak',
    ICICI: 'icici',
    RBL: 'rbl',
    BOB: 'bob',
    STANDARD_CHARTERED: 'standard chartered',
    AXIS: 'axis',
    AU: 'au',
    YES: 'yes',
    SBI: 'sbi',
    FED: 'fed',
    HSBC: 'hsbc',
    CITI: 'citi',
    AMEX: 'amex',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type CardEMICardBankNameEnum = typeof CardEMICardBankNameEnum[keyof typeof CardEMICardBankNameEnum];

/**
 * Complete card emi payment method
 * @export
 * @interface CardEMIPaymentMethod
 */
export interface CardEMIPaymentMethod {
    /**
     * 
     * @type {CardEMI}
     * @memberof CardEMIPaymentMethod
     */
    'emi': CardEMI;
}
/**
 * 
 * @export
 * @interface CardOffer
 */
export interface CardOffer {
    /**
     * 
     * @type {Array<string>}
     * @memberof CardOffer
     */
    'type': Array<string>;
    /**
     * Bank Name of Card.
     * @type {string}
     * @memberof CardOffer
     */
    'bank_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CardOffer
     */
    'scheme_name': Array<string>;
}
/**
 * The card payment object is used to make payment using either plain card number, saved card instrument id or using cryptogram 
 * @export
 * @interface CardPaymentMethod
 */
export interface CardPaymentMethod {
    /**
     * 
     * @type {Card}
     * @memberof CardPaymentMethod
     */
    'card': Card;
}
/**
 * Request body for cardless emi payment method
 * @export
 * @interface CardlessEMI
 */
export interface CardlessEMI {
    /**
     * The channel for cardless EMI is always `link`
     * @type {string}
     * @memberof CardlessEMI
     */
    'channel'?: string;
    /**
     * One of [`flexmoney`, `zestmoney`, `hdfc`, `icici`, `cashe`, `idfc`, `kotak`]
     * @type {string}
     * @memberof CardlessEMI
     */
    'provider'?: CardlessEMIProviderEnum;
    /**
     * Customers phone number for this payment instrument. If the customer is not eligible you will receive a 400 error with type as \'invalid_request_error\' and code as \'invalid_request_error\'
     * @type {string}
     * @memberof CardlessEMI
     */
    'phone'?: string;
    /**
     * EMI tenure for the selected provider. This is mandatory when provider is one of [`hdfc`, `icici`, `cashe`, `idfc`, `kotak`]
     * @type {number}
     * @memberof CardlessEMI
     */
    'emi_tenure'?: number;
}

export const CardlessEMIProviderEnum = {
    FLEXMONEY: 'flexmoney',
    ZESTMONEY: 'zestmoney',
    HDFC: 'hdfc',
    ICICI: 'icici',
    CASHE: 'cashe',
    IDFC: 'idfc',
    KOTAK: 'kotak',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type CardlessEMIProviderEnum = typeof CardlessEMIProviderEnum[keyof typeof CardlessEMIProviderEnum];

/**
 * cardless EMI object
 * @export
 * @interface CardlessEMIEntity
 */
export interface CardlessEMIEntity {
    /**
     * 
     * @type {string}
     * @memberof CardlessEMIEntity
     */
    'payment_method'?: string;
    /**
     * 
     * @type {Array<EMIPlansArray>}
     * @memberof CardlessEMIEntity
     */
    'emi_plans'?: Array<EMIPlansArray>;
}
/**
 * cardless EMI payment method object
 * @export
 * @interface CardlessEMIPaymentMethod
 */
export interface CardlessEMIPaymentMethod {
    /**
     * 
     * @type {CardlessEMI}
     * @memberof CardlessEMIPaymentMethod
     */
    'cardless_emi': CardlessEMI;
}
/**
 * cardless EMI query object
 * @export
 * @interface CardlessEMIQueries
 */
export interface CardlessEMIQueries {
    /**
     * OrderId of the order. Either of `order_id` or `amount` is mandatory.
     * @type {string}
     * @memberof CardlessEMIQueries
     */
    'order_id'?: string;
    /**
     * Amount of the order. OrderId of the order. Either of `order_id` or `amount` is mandatory.
     * @type {number}
     * @memberof CardlessEMIQueries
     */
    'amount'?: number;
    /**
     * 
     * @type {CustomerDetailsCardlessEMI}
     * @memberof CardlessEMIQueries
     */
    'customer_details'?: CustomerDetailsCardlessEMI;
}
/**
 * Cashback detail boject
 * @export
 * @interface CashbackDetails
 */
export interface CashbackDetails {
    /**
     * Type of discount
     * @type {string}
     * @memberof CashbackDetails
     */
    'cashback_type': CashbackDetailsCashbackTypeEnum;
    /**
     * Value of Discount.
     * @type {number}
     * @memberof CashbackDetails
     */
    'cashback_value': number;
    /**
     * Maximum Value of Cashback allowed.
     * @type {number}
     * @memberof CashbackDetails
     */
    'max_cashback_amount': number;
}

export const CashbackDetailsCashbackTypeEnum = {
    FLAT: 'flat',
    PERCENTAGE: 'percentage',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type CashbackDetailsCashbackTypeEnum = typeof CashbackDetailsCashbackTypeEnum[keyof typeof CashbackDetailsCashbackTypeEnum];

/**
 * 
 * @export
 * @interface ChargesDetails
 */
export interface ChargesDetails {
    /**
     * 
     * @type {number}
     * @memberof ChargesDetails
     */
    'service_charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargesDetails
     */
    'service_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargesDetails
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChargesDetails
     */
    'billed_to'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargesDetails
     */
    'is_postpaid'?: boolean;
}
/**
 * Request body to create a customer at cashfree
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * Customer Phone Number
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'customer_phone': string;
    /**
     * Customer Email
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'customer_email'?: string;
    /**
     * Customer Name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'customer_name'?: string;
}
/**
 * Request paramenters for link creation
 * @export
 * @interface CreateLinkRequest
 */
export interface CreateLinkRequest {
    /**
     * Unique Identifier (provided by merchant) for the Link. Alphanumeric and only - and _ allowed (50 character limit). Use this for other link-related APIs.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_id': string;
    /**
     * Amount to be collected using this link. Provide upto two decimals for paise.
     * @type {number}
     * @memberof CreateLinkRequest
     */
    'link_amount': number;
    /**
     * Currency for the payment link. Default is INR. Contact care@cashfree.com to enable new currencies.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_currency': string;
    /**
     * A brief description for which payment must be collected. This is shown to the customer.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_purpose': string;
    /**
     * 
     * @type {LinkCustomerDetailsEntity}
     * @memberof CreateLinkRequest
     */
    'customer_details': LinkCustomerDetailsEntity;
    /**
     * If \"true\", customer can make partial payments for the link.
     * @type {boolean}
     * @memberof CreateLinkRequest
     */
    'link_partial_payments'?: boolean;
    /**
     * Minimum amount in first installment that needs to be paid by the customer if partial payments are enabled. This should be less than the link_amount.
     * @type {number}
     * @memberof CreateLinkRequest
     */
    'link_minimum_partial_amount'?: number;
    /**
     * Time after which the link expires. Customers will not be able to make the payment beyond the time specified here. You can provide them in a valid ISO 8601 time format. Default is 30 days.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_expiry_time'?: string;
    /**
     * 
     * @type {LinkNotifyEntity}
     * @memberof CreateLinkRequest
     */
    'link_notify'?: LinkNotifyEntity;
    /**
     * If \"true\", reminders will be sent to customers for collecting payments.
     * @type {boolean}
     * @memberof CreateLinkRequest
     */
    'link_auto_reminders'?: boolean;
    /**
     * Key-value pair that can be used to store additional information about the entity. Maximum 5 key-value pairs
     * @type {{ [key: string]: string; }}
     * @memberof CreateLinkRequest
     */
    'link_notes'?: { [key: string]: string; };
    /**
     * 
     * @type {LinkMetaResponseEntity}
     * @memberof CreateLinkRequest
     */
    'link_meta'?: LinkMetaResponseEntity;
    /**
     * If you have Easy split enabled in your Cashfree account then you can use this option to split the order amount.
     * @type {Array<VendorSplit>}
     * @memberof CreateLinkRequest
     */
    'order_splits'?: Array<VendorSplit>;
}
/**
 * create offer backend request object
 * @export
 * @interface CreateOfferRequest
 */
export interface CreateOfferRequest {
    /**
     * 
     * @type {OfferMeta}
     * @memberof CreateOfferRequest
     */
    'offer_meta': OfferMeta;
    /**
     * 
     * @type {OfferTnc}
     * @memberof CreateOfferRequest
     */
    'offer_tnc': OfferTnc;
    /**
     * 
     * @type {OfferDetails}
     * @memberof CreateOfferRequest
     */
    'offer_details': OfferDetails;
    /**
     * 
     * @type {OfferValidations}
     * @memberof CreateOfferRequest
     */
    'offer_validations': OfferValidations;
}
/**
 * Request body to create an order at cashfree
 * @export
 * @interface CreateOrderRequest
 */
export interface CreateOrderRequest {
    /**
     * Order identifier present in your system. Alphanumeric, \'_\' and \'-\' only
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_id'?: string;
    /**
     * Bill amount for the order. Provide upto two decimals. 10.15 means Rs 10 and 15 paisa
     * @type {number}
     * @memberof CreateOrderRequest
     */
    'order_amount': number;
    /**
     * Currency for the order. INR if left empty. Contact care@cashfree.com to enable new currencies.
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_currency': string;
    /**
     * 
     * @type {CustomerDetails}
     * @memberof CreateOrderRequest
     */
    'customer_details': CustomerDetails;
    /**
     * 
     * @type {TerminalDetails}
     * @memberof CreateOrderRequest
     */
    'terminal'?: TerminalDetails;
    /**
     * 
     * @type {OrderMeta}
     * @memberof CreateOrderRequest
     */
    'order_meta'?: OrderMeta;
    /**
     * Time after which the order expires. Customers will not be able to make the payment beyond the time specified here. We store timestamps in IST, but you can provide them in a valid ISO 8601 time format. Example 2021-07-02T10:20:12+05:30 for IST, 2021-07-02T10:20:12Z for UTC
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_expiry_time'?: string;
    /**
     * Order note for reference.
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_note'?: string;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof CreateOrderRequest
     */
    'order_tags'?: { [key: string]: string; };
    /**
     * If you have Easy split enabled in your Cashfree account then you can use this option to split the order amount.
     * @type {Array<VendorSplit>}
     * @memberof CreateOrderRequest
     */
    'order_splits'?: Array<VendorSplit>;
}
/**
 * Request body to create a terminal
 * @export
 * @interface CreateTerminalRequest
 */
export interface CreateTerminalRequest {
    /**
     * merchant’s internal terminal id
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_id': string;
    /**
     * phone number assigned to the terminal
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_phone_no': string;
    /**
     * terminal name to be assigned by merchants
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_name': string;
    /**
     * address of the terminal. required for STOREFRONT
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_address'?: string;
    /**
     * terminal email ID of the AGENT/STOREFRONT assigned by merchants.
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_email': string;
    /**
     * additional note for terminal
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_note'?: string;
    /**
     * mention the terminal type. possible values - AGENT, STOREFRONT.
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_type': string;
    /**
     * 
     * @type {CreateTerminalRequestTerminalMeta}
     * @memberof CreateTerminalRequest
     */
    'terminal_meta'?: CreateTerminalRequestTerminalMeta;
}
/**
 * terminal metadata. required field for storefront.
 * @export
 * @interface CreateTerminalRequestTerminalMeta
 */
export interface CreateTerminalRequestTerminalMeta {
    /**
     * name of the STOREFRONT operator.
     * @type {string}
     * @memberof CreateTerminalRequestTerminalMeta
     */
    'terminal_operator'?: string;
}
/**
 * Request body to create a terminal transaction
 * @export
 * @interface CreateTerminalTransactionRequest
 */
export interface CreateTerminalTransactionRequest {
    /**
     * cashfree order ID that was returned while creating an order.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'cf_order_id': string;
    /**
     * cashfree terminal id. this is a required parameter when you do not provide the terminal phone number.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'cf_terminal_id'?: string;
    /**
     * mention the payment method used for the transaction. possible values - QR_CODE, LINK.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'payment_method': string;
    /**
     * agent mobile number assigned to the terminal. this is a required parameter when you do not provide the cf_terminal_id.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'terminal_phone_no'?: string;
}
/**
 * Create Vendor Request
 * @export
 * @interface CreateVendorRequest
 */
export interface CreateVendorRequest {
    /**
     * Specify the unique Vendor ID to identify the beneficiary. Alphanumeric and underscore (_) allowed.
     * @type {string}
     * @memberof CreateVendorRequest
     */
    'vendor_id': string;
    /**
     * Specify the status of vendor that should be updated. Possible values: ACTIVE,BLOCKED, DELETED
     * @type {string}
     * @memberof CreateVendorRequest
     */
    'status': string;
    /**
     * Specify the name of the vendor to be updated. Name should not have any special character except . / - &
     * @type {string}
     * @memberof CreateVendorRequest
     */
    'name': string;
    /**
     * Specify the vendor email ID that should be updated. String in email ID format (Ex:johndoe_1@cashfree.com) should contain @ and dot (.)
     * @type {string}
     * @memberof CreateVendorRequest
     */
    'email': string;
    /**
     * Specify the beneficiaries phone number to be updated. Phone number registered in India (only digits, 8 - 12 characters after excluding +91).
     * @type {string}
     * @memberof CreateVendorRequest
     */
    'phone': string;
    /**
     * Specify if the vendor bank account details should be verified. Possible values: true or false
     * @type {boolean}
     * @memberof CreateVendorRequest
     */
    'verify_account'?: boolean;
    /**
     * Update if the vendor will have dashboard access or not. Possible values are: true or false
     * @type {boolean}
     * @memberof CreateVendorRequest
     */
    'dashboard_access'?: boolean;
    /**
     * Specify the settlement cycle to be updated. View the settlement cycle details from the \"Settlement Cycles Supported\" table. If no schedule option is configured, the settlement cycle ID \"1\" will be in effect. Select \"8\" or \"9\" if you want to schedule instant vendor settlements.
     * @type {number}
     * @memberof CreateVendorRequest
     */
    'schedule_option'?: number;
    /**
     * Specify the vendor bank account details to be updated.
     * @type {Array<BankDetails>}
     * @memberof CreateVendorRequest
     */
    'bank'?: Array<BankDetails>;
    /**
     * Updated beneficiary upi vpa. Alphanumeric, dot (.), hyphen (-), at sign (@), and underscore allowed (100 character limit). Note: underscore and dot (.) gets accepted before and after @, but hyphen (-) is only accepted before @ sign.
     * @type {Array<UpiDetails>}
     * @memberof CreateVendorRequest
     */
    'upi'?: Array<UpiDetails>;
    /**
     * Specify the kyc details that should be updated.
     * @type {Array<KycDetails>}
     * @memberof CreateVendorRequest
     */
    'kyc_details': Array<KycDetails>;
}
/**
 * Create Vendor Response
 * @export
 * @interface CreateVendorResponse
 */
export interface CreateVendorResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateVendorResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVendorResponse
     */
    'status'?: string;
    /**
     * 
     * @type {Array<BankDetails>}
     * @memberof CreateVendorResponse
     */
    'bank'?: Array<BankDetails>;
    /**
     * 
     * @type {string}
     * @memberof CreateVendorResponse
     */
    'upi'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateVendorResponse
     */
    'phone'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateVendorResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVendorResponse
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {Array<ScheduleOption>}
     * @memberof CreateVendorResponse
     */
    'schedule_option'?: Array<ScheduleOption>;
    /**
     * 
     * @type {Array<KycDetails>}
     * @memberof CreateVendorResponse
     */
    'kyc_details'?: Array<KycDetails>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateVendorResponse
     */
    'dashboard_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateVendorResponse
     */
    'bank_details'?: string;
}
/**
 * Crytogram Card object
 * @export
 * @interface CryptogramEntity
 */
export interface CryptogramEntity {
    /**
     * instrument_id of saved instrument
     * @type {string}
     * @memberof CryptogramEntity
     */
    'instrument_id'?: string;
    /**
     * TRID issued by card networks
     * @type {string}
     * @memberof CryptogramEntity
     */
    'token_requestor_id'?: string;
    /**
     * token pan number
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_number'?: string;
    /**
     * token pan expiry month
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_expiry_mm'?: string;
    /**
     * token pan expiry year
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_expiry_yy'?: string;
    /**
     * cryptogram
     * @type {string}
     * @memberof CryptogramEntity
     */
    'cryptogram'?: string;
    /**
     * last 4 digits of original card number
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_display'?: string;
}
/**
 * The customer details that are necessary. Note that you can pass dummy details if your use case does not require the customer details.
 * @export
 * @interface CustomerDetails
 */
export interface CustomerDetails {
    /**
     * A unique identifier for the customer. Use alphanumeric values only.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_id': string;
    /**
     * Customer email address.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_email'?: string;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_phone': string;
    /**
     * Name of the customer.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_name'?: string;
    /**
     * Customer bank account. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_bank_account_number'?: string;
    /**
     * Customer bank IFSC. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_bank_ifsc'?: string;
    /**
     * Customer bank code. Required for net banking payments, if you want to do a bank account check (TPV)
     * @type {number}
     * @memberof CustomerDetails
     */
    'customer_bank_code'?: number;
    /**
     * Customer identifier at Cashfree. You will get this when you create/get customer
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_uid'?: string;
}
/**
 * Details of the customer for whom eligibility is being checked.
 * @export
 * @interface CustomerDetailsCardlessEMI
 */
export interface CustomerDetailsCardlessEMI {
    /**
     * Phone Number of the customer
     * @type {string}
     * @memberof CustomerDetailsCardlessEMI
     */
    'customer_phone': string;
}
/**
 * The complete customer entity
 * @export
 * @interface CustomerEntity
 */
export interface CustomerEntity {
    /**
     * unique id generated by cashfree for your customer
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_uid'?: string;
    /**
     * Customer Phone Number
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_phone'?: string;
    /**
     * Customer Email
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_email'?: string;
    /**
     * Customer Name
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_name'?: string;
}
/**
 * detils of the discount object of offer
 * @export
 * @interface DiscountDetails
 */
export interface DiscountDetails {
    /**
     * Type of discount
     * @type {string}
     * @memberof DiscountDetails
     */
    'discount_type': DiscountDetailsDiscountTypeEnum;
    /**
     * Value of Discount.
     * @type {number}
     * @memberof DiscountDetails
     */
    'discount_value': number;
    /**
     * Maximum Value of Discount allowed.
     * @type {number}
     * @memberof DiscountDetails
     */
    'max_discount_amount': number;
}

export const DiscountDetailsDiscountTypeEnum = {
    FLAT: 'flat',
    PERCENTAGE: 'percentage',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type DiscountDetailsDiscountTypeEnum = typeof DiscountDetailsDiscountTypeEnum[keyof typeof DiscountDetailsDiscountTypeEnum];

/**
 * 
 * @export
 * @interface EMIOffer
 */
export interface EMIOffer {
    /**
     * Type of emi offer. Possible values are `credit_card_emi`, `debit_card_emi`, `cardless_emi`
     * @type {string}
     * @memberof EMIOffer
     */
    'type': string;
    /**
     * Bank Name
     * @type {string}
     * @memberof EMIOffer
     */
    'issuer': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EMIOffer
     */
    'tenures': Array<number>;
}
/**
 * Single EMI object
 * @export
 * @interface EMIPlansArray
 */
export interface EMIPlansArray {
    /**
     * 
     * @type {number}
     * @memberof EMIPlansArray
     */
    'tenure'?: number;
    /**
     * 
     * @type {number}
     * @memberof EMIPlansArray
     */
    'interest_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof EMIPlansArray
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof EMIPlansArray
     */
    'emi'?: number;
    /**
     * 
     * @type {number}
     * @memberof EMIPlansArray
     */
    'total_interest'?: number;
    /**
     * 
     * @type {number}
     * @memberof EMIPlansArray
     */
    'total_amount'?: number;
}
/**
 * ES Order Recon Request
 * @export
 * @interface ESOrderReconRequest
 */
export interface ESOrderReconRequest {
    /**
     * 
     * @type {ESOrderReconRequestFilters}
     * @memberof ESOrderReconRequest
     */
    'filters': ESOrderReconRequestFilters;
    /**
     * 
     * @type {ESOrderReconRequestPagination}
     * @memberof ESOrderReconRequest
     */
    'pagination': ESOrderReconRequestPagination;
}
/**
 * Provide the filter object details.
 * @export
 * @interface ESOrderReconRequestFilters
 */
export interface ESOrderReconRequestFilters {
    /**
     * Specify the start data from which you want to get the recon data.
     * @type {string}
     * @memberof ESOrderReconRequestFilters
     */
    'start_date'?: string;
    /**
     * Specify the end data till which you want to get the recon data.
     * @type {string}
     * @memberof ESOrderReconRequestFilters
     */
    'end_date'?: string;
    /**
     * Please provide list of order ids for which you want to get the recon data.
     * @type {Array<string>}
     * @memberof ESOrderReconRequestFilters
     */
    'order_ids'?: Array<string>;
}
/**
 * Set limit based on your requirement. Pagination limit will fetch a set of orders, next set of orders can be generated using the cursor shared in previous response of the same API.
 * @export
 * @interface ESOrderReconRequestPagination
 */
export interface ESOrderReconRequestPagination {
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconRequestPagination
     */
    'cursor'?: string;
    /**
     * Set the minimum/maximum limit for number of filtered data. Min value - 10, Max value - 100.
     * @type {number}
     * @memberof ESOrderReconRequestPagination
     */
    'limit'?: number;
}
/**
 * ES Order Recon Response
 * @export
 * @interface ESOrderReconResponse
 */
export interface ESOrderReconResponse {
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponse
     */
    'cursor'?: string;
    /**
     * 
     * @type {Array<ESOrderReconResponseDataInner>}
     * @memberof ESOrderReconResponse
     */
    'data'?: Array<ESOrderReconResponseDataInner>;
    /**
     * 
     * @type {number}
     * @memberof ESOrderReconResponse
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface ESOrderReconResponseDataInner
 */
export interface ESOrderReconResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof ESOrderReconResponseDataInner
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'settlement_eligibility_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'merchant_order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'tx_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'settled'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'entity_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'merchant_settlement_utr'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'sale_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'customer_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'customer_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'customer_phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'merchant_vendor_commission'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'split_service_charge'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'split_service_tax'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'pg_service_tax'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'pg_service_charge'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'pg_charge_postpaid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'merchant_settlement_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'added_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'entity_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'settlement_initiated_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'settlement_time'?: string;
    /**
     * 
     * @type {Array<ESOrderReconResponseDataInnerOrderSplitsInner>}
     * @memberof ESOrderReconResponseDataInner
     */
    'order_splits'?: Array<ESOrderReconResponseDataInnerOrderSplitsInner>;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInner
     */
    'eligible_split_balance'?: string;
}
/**
 * 
 * @export
 * @interface ESOrderReconResponseDataInnerOrderSplitsInner
 */
export interface ESOrderReconResponseDataInnerOrderSplitsInner {
    /**
     * 
     * @type {Array<ESOrderReconResponseDataInnerOrderSplitsInnerSplitInner>}
     * @memberof ESOrderReconResponseDataInnerOrderSplitsInner
     */
    'split'?: Array<ESOrderReconResponseDataInnerOrderSplitsInnerSplitInner>;
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInnerOrderSplitsInner
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface ESOrderReconResponseDataInnerOrderSplitsInnerSplitInner
 */
export interface ESOrderReconResponseDataInnerOrderSplitsInnerSplitInner {
    /**
     * 
     * @type {string}
     * @memberof ESOrderReconResponseDataInnerOrderSplitsInnerSplitInner
     */
    'merchant_vendor_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ESOrderReconResponseDataInnerOrderSplitsInnerSplitInner
     */
    'percentage'?: number;
    /**
     * 
     * @type {object}
     * @memberof ESOrderReconResponseDataInnerOrderSplitsInnerSplitInner
     */
    'tags'?: object;
}
/**
 * Carless EMI eligible entity
 * @export
 * @interface EligibilityCardlessEMIEntity
 */
export interface EligibilityCardlessEMIEntity {
    /**
     * 
     * @type {boolean}
     * @memberof EligibilityCardlessEMIEntity
     */
    'eligibility'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EligibilityCardlessEMIEntity
     */
    'entity_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EligibilityCardlessEMIEntity
     */
    'entity_value'?: string;
    /**
     * 
     * @type {CardlessEMIEntity}
     * @memberof EligibilityCardlessEMIEntity
     */
    'entity_details'?: CardlessEMIEntity;
}
/**
 * eligibilty request for cardless
 * @export
 * @interface EligibilityFetchCardlessEMIRequest
 */
export interface EligibilityFetchCardlessEMIRequest {
    /**
     * 
     * @type {CardlessEMIQueries}
     * @memberof EligibilityFetchCardlessEMIRequest
     */
    'queries': CardlessEMIQueries;
}
/**
 * Eligiblty API request
 * @export
 * @interface EligibilityFetchOffersRequest
 */
export interface EligibilityFetchOffersRequest {
    /**
     * 
     * @type {OfferQueries}
     * @memberof EligibilityFetchOffersRequest
     */
    'queries': OfferQueries;
    /**
     * 
     * @type {OfferFilters}
     * @memberof EligibilityFetchOffersRequest
     */
    'filters'?: OfferFilters;
}
/**
 * Request to get eligible paylater payment methods
 * @export
 * @interface EligibilityFetchPaylaterRequest
 */
export interface EligibilityFetchPaylaterRequest {
    /**
     * 
     * @type {CardlessEMIQueries}
     * @memberof EligibilityFetchPaylaterRequest
     */
    'queries': CardlessEMIQueries;
}
/**
 * eligibilty request to find eligible payment method
 * @export
 * @interface EligibilityFetchPaymentMethodsRequest
 */
export interface EligibilityFetchPaymentMethodsRequest {
    /**
     * 
     * @type {PaymentMethodsQueries}
     * @memberof EligibilityFetchPaymentMethodsRequest
     */
    'queries': PaymentMethodsQueries;
    /**
     * 
     * @type {PaymentMethodsFilters}
     * @memberof EligibilityFetchPaymentMethodsRequest
     */
    'filters'?: PaymentMethodsFilters;
}
/**
 * Eligible offer object
 * @export
 * @interface EligibilityOfferEntity
 */
export interface EligibilityOfferEntity {
    /**
     * 
     * @type {boolean}
     * @memberof EligibilityOfferEntity
     */
    'eligibility'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EligibilityOfferEntity
     */
    'entity_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EligibilityOfferEntity
     */
    'entity_value'?: string;
    /**
     * 
     * @type {OfferEntity}
     * @memberof EligibilityOfferEntity
     */
    'entity_details'?: OfferEntity;
}
/**
 * Eligible paylater payment method
 * @export
 * @interface EligibilityPaylaterEntity
 */
export interface EligibilityPaylaterEntity {
    /**
     * 
     * @type {boolean}
     * @memberof EligibilityPaylaterEntity
     */
    'eligibility'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EligibilityPaylaterEntity
     */
    'entity_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EligibilityPaylaterEntity
     */
    'entity_value'?: string;
    /**
     * 
     * @type {PaylaterEntity}
     * @memberof EligibilityPaylaterEntity
     */
    'entity_details'?: PaylaterEntity;
}
/**
 * Eligible payment methods details
 * @export
 * @interface EligibilityPaymentMethodsEntity
 */
export interface EligibilityPaymentMethodsEntity {
    /**
     * 
     * @type {boolean}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'eligibility'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'entity_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'entity_value'?: string;
    /**
     * 
     * @type {EligibilityPaymentMethodsEntityEntityDetails}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'entity_details'?: EligibilityPaymentMethodsEntityEntityDetails;
}
/**
 * 
 * @export
 * @interface EligibilityPaymentMethodsEntityEntityDetails
 */
export interface EligibilityPaymentMethodsEntityEntityDetails {
    /**
     * 
     * @type {Array<PaymentModeDetails>}
     * @memberof EligibilityPaymentMethodsEntityEntityDetails
     */
    'payment_method_details'?: Array<PaymentModeDetails>;
}
/**
 * The error details are present only for failed payments
 * @export
 * @interface ErrorDetailsInPaymentsEntity
 */
export interface ErrorDetailsInPaymentsEntity {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_source'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_code_raw'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_description_raw'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_subcode_raw'?: string;
}
/**
 * Recon object
 * @export
 * @interface FetchReconRequest
 */
export interface FetchReconRequest {
    /**
     * 
     * @type {FetchReconRequestPagination}
     * @memberof FetchReconRequest
     */
    'pagination': FetchReconRequestPagination;
    /**
     * 
     * @type {FetchReconRequestFilters}
     * @memberof FetchReconRequest
     */
    'filters': FetchReconRequestFilters;
}
/**
 * 
 * @export
 * @interface FetchReconRequestFilters
 */
export interface FetchReconRequestFilters {
    /**
     * Specify the start date from when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchReconRequestFilters
     */
    'start_date': string;
    /**
     * Specify the end date till when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchReconRequestFilters
     */
    'end_date': string;
}
/**
 * To fetch the next set of settlements, pass the cursor received in the response to the next API call.   To receive the data for the first time, pass the cursor as null.   Limit would be number of settlements that you want to receive.
 * @export
 * @interface FetchReconRequestPagination
 */
export interface FetchReconRequestPagination {
    /**
     * Number of settlements you want to fetch in the next iteration. Maximum limit is 1000, default value is 10.
     * @type {number}
     * @memberof FetchReconRequestPagination
     */
    'limit': number;
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof FetchReconRequestPagination
     */
    'cursor'?: string;
}
/**
 * Request to fetch settlement
 * @export
 * @interface FetchSettlementsRequest
 */
export interface FetchSettlementsRequest {
    /**
     * 
     * @type {FetchSettlementsRequestPagination}
     * @memberof FetchSettlementsRequest
     */
    'pagination': FetchSettlementsRequestPagination;
    /**
     * 
     * @type {FetchSettlementsRequestFilters}
     * @memberof FetchSettlementsRequest
     */
    'filters': FetchSettlementsRequestFilters;
}
/**
 * Specify either the Settlement ID, Settlement UTR, or start date and end date to fetch the settlement details.
 * @export
 * @interface FetchSettlementsRequestFilters
 */
export interface FetchSettlementsRequestFilters {
    /**
     * List of settlement IDs for which you want the settlement reconciliation details.
     * @type {Array<string>}
     * @memberof FetchSettlementsRequestFilters
     */
    'cf_settlement_ids'?: Array<string>;
    /**
     * List of settlement UTRs for which you want the settlement reconciliation details.
     * @type {Array<string>}
     * @memberof FetchSettlementsRequestFilters
     */
    'settlement_utrs'?: Array<string>;
    /**
     * Specify the start date from when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchSettlementsRequestFilters
     */
    'start_date'?: string;
    /**
     * Specify the end date till when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchSettlementsRequestFilters
     */
    'end_date'?: string;
}
/**
 * To fetch the next set of settlements, pass the cursor received in the response to the next API call.   To receive the data for the first time, pass the cursor as null.   Limit would be number of settlements that you want to receive.
 * @export
 * @interface FetchSettlementsRequestPagination
 */
export interface FetchSettlementsRequestPagination {
    /**
     * The number of settlements you want to fetch. Maximum limit is 1000, default value is 10.
     * @type {number}
     * @memberof FetchSettlementsRequestPagination
     */
    'limit': number;
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof FetchSettlementsRequestPagination
     */
    'cursor'?: string;
}
/**
 * Fetch Static QR Codes using terminal ID or phone number
 * @export
 * @interface FetchTerminalQRCodesEntity
 */
export interface FetchTerminalQRCodesEntity {
    /**
     * Name of the bank that is linked to the Static QR.
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'bank'?: string;
    /**
     * Base-64 Encoded QR Code URL
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'qrCode'?: string;
    /**
     * URL of the qr Code.
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'qrCodeUrl'?: string;
    /**
     * Status of the static QR.
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'status'?: string;
}
/**
 * Error when idempotency fails. Different request body with the same idempotent key
 * @export
 * @interface IdempotencyError
 */
export interface IdempotencyError {
    /**
     * 
     * @type {string}
     * @memberof IdempotencyError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdempotencyError
     */
    'code'?: string;
    /**
     * idempotency_error
     * @type {string}
     * @memberof IdempotencyError
     */
    'type'?: IdempotencyErrorTypeEnum;
}

export const IdempotencyErrorTypeEnum = {
    IDEMPOTENCY_ERROR: 'idempotency_error',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type IdempotencyErrorTypeEnum = typeof IdempotencyErrorTypeEnum[keyof typeof IdempotencyErrorTypeEnum];

/**
 * Saved card instrument object
 * @export
 * @interface InstrumentEntity
 */
export interface InstrumentEntity {
    /**
     * customer_id for which the instrument was saved
     * @type {string}
     * @memberof InstrumentEntity
     */
    'customer_id'?: string;
    /**
     * cf_payment_id of the successful transaction done while saving instrument
     * @type {string}
     * @memberof InstrumentEntity
     */
    'afa_reference'?: string;
    /**
     * saved instrument id
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_id'?: string;
    /**
     * Type of the saved instrument
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_type'?: InstrumentEntityInstrumentTypeEnum;
    /**
     * Unique id for the saved instrument
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_uid'?: string;
    /**
     * masked card number displayed to the customer
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_display'?: string;
    /**
     * Status of the saved instrument.
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_status'?: InstrumentEntityInstrumentStatusEnum;
    /**
     * Timestamp at which instrument was saved.
     * @type {string}
     * @memberof InstrumentEntity
     */
    'created_at'?: string;
    /**
     * 
     * @type {SavedInstrumentMeta}
     * @memberof InstrumentEntity
     */
    'instrument_meta'?: SavedInstrumentMeta;
}

export const InstrumentEntityInstrumentTypeEnum = {
    CARD: 'card',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type InstrumentEntityInstrumentTypeEnum = typeof InstrumentEntityInstrumentTypeEnum[keyof typeof InstrumentEntityInstrumentTypeEnum];
export const InstrumentEntityInstrumentStatusEnum = {
    ACTIVE: 'ACTIVE',
    INACTIVE: 'INACTIVE',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type InstrumentEntityInstrumentStatusEnum = typeof InstrumentEntityInstrumentStatusEnum[keyof typeof InstrumentEntityInstrumentStatusEnum];

/**
 * Instrument webhook object
 * @export
 * @interface InstrumentWebhook
 */
export interface InstrumentWebhook {
    /**
     * 
     * @type {InstrumentWebhookData}
     * @memberof InstrumentWebhook
     */
    'data'?: InstrumentWebhookData;
}
/**
 * 
 * @export
 * @interface InstrumentWebhookData
 */
export interface InstrumentWebhookData {
    /**
     * 
     * @type {InstrumentWebhookDataEntity}
     * @memberof InstrumentWebhookData
     */
    'data'?: InstrumentWebhookDataEntity;
    /**
     * 
     * @type {string}
     * @memberof InstrumentWebhookData
     */
    'event_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstrumentWebhookData
     */
    'type'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface InstrumentWebhookDataEntity
 */
export interface InstrumentWebhookDataEntity {
    /**
     * 
     * @type {InstrumentEntity}
     * @memberof InstrumentWebhookDataEntity
     */
    'instrument'?: InstrumentEntity;
}
/**
 * 
 * @export
 * @interface KycDetails
 */
export interface KycDetails {
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'account_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'business_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof KycDetails
     */
    'uidai'?: number;
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'gst'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'cin'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'pan'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'passport_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'driving_license'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDetails
     */
    'voter_id'?: string;
}
/**
 * Payment link customer entity
 * @export
 * @interface LinkCustomerDetailsEntity
 */
export interface LinkCustomerDetailsEntity {
    /**
     * Customer phone number
     * @type {string}
     * @memberof LinkCustomerDetailsEntity
     */
    'customer_phone': string;
    /**
     * Customer email address
     * @type {string}
     * @memberof LinkCustomerDetailsEntity
     */
    'customer_email'?: string;
    /**
     * Customer name
     * @type {string}
     * @memberof LinkCustomerDetailsEntity
     */
    'customer_name'?: string;
}
/**
 * Payment link success creation response object
 * @export
 * @interface LinkEntity
 */
export interface LinkEntity {
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'cf_link_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'link_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'link_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'link_currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof LinkEntity
     */
    'link_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof LinkEntity
     */
    'link_amount_paid'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LinkEntity
     */
    'link_partial_payments'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LinkEntity
     */
    'link_minimum_partial_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'link_purpose'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'link_created_at'?: string;
    /**
     * 
     * @type {LinkCustomerDetailsEntity}
     * @memberof LinkEntity
     */
    'customer_details'?: LinkCustomerDetailsEntity;
    /**
     * 
     * @type {LinkMetaResponseEntity}
     * @memberof LinkEntity
     */
    'link_meta'?: LinkMetaResponseEntity;
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'link_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkEntity
     */
    'link_expiry_time'?: string;
    /**
     * Key-value pair that can be used to store additional information about the entity. Maximum 5 key-value pairs
     * @type {{ [key: string]: string; }}
     * @memberof LinkEntity
     */
    'link_notes'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof LinkEntity
     */
    'link_auto_reminders'?: boolean;
    /**
     * 
     * @type {LinkNotifyEntity}
     * @memberof LinkEntity
     */
    'link_notify'?: LinkNotifyEntity;
    /**
     * Base64 encoded string for payment link. You can scan with camera to open a link in the browser to complete the payment.
     * @type {string}
     * @memberof LinkEntity
     */
    'link_qrcode'?: string;
    /**
     * 
     * @type {Array<VendorSplit>}
     * @memberof LinkEntity
     */
    'order_splits'?: Array<VendorSplit>;
}
/**
 * Payment link meta information object
 * @export
 * @interface LinkMetaResponseEntity
 */
export interface LinkMetaResponseEntity {
    /**
     * Notification URL for server-server communication. It should be an https URL.
     * @type {string}
     * @memberof LinkMetaResponseEntity
     */
    'notify_url'?: string;
    /**
     * If \"true\", link will directly open UPI Intent flow on mobile, and normal link flow elsewhere
     * @type {boolean}
     * @memberof LinkMetaResponseEntity
     */
    'upi_intent'?: boolean;
    /**
     * The URL to which user will be redirected to after the payment is done on the link. Maximum length: 250.
     * @type {string}
     * @memberof LinkMetaResponseEntity
     */
    'return_url'?: string;
    /**
     * Allowed payment modes for this link. Pass comma-separated values among following options - \"cc\", \"dc\", \"ccc\", \"ppc\", \"nb\", \"upi\", \"paypal\", \"app\". Leave it blank to show all available payment methods
     * @type {string}
     * @memberof LinkMetaResponseEntity
     */
    'payment_methods'?: string;
}
/**
 * Payment link Notify Object for SMS and Email
 * @export
 * @interface LinkNotifyEntity
 */
export interface LinkNotifyEntity {
    /**
     * If \"true\", Cashfree will send sms on customer_phone
     * @type {boolean}
     * @memberof LinkNotifyEntity
     */
    'send_sms'?: boolean;
    /**
     * If \"true\", Cashfree will send email on customer_email
     * @type {boolean}
     * @memberof LinkNotifyEntity
     */
    'send_email'?: boolean;
}
/**
 * Payment method for netbanking object
 * @export
 * @interface NetBankingPaymentMethod
 */
export interface NetBankingPaymentMethod {
    /**
     * 
     * @type {Netbanking}
     * @memberof NetBankingPaymentMethod
     */
    'netbanking': Netbanking;
}
/**
 * Netbanking payment method request body
 * @export
 * @interface Netbanking
 */
export interface Netbanking {
    /**
     * The channel for netbanking will always be `link`
     * @type {string}
     * @memberof Netbanking
     */
    'channel': string;
    /**
     * Bank code
     * @type {number}
     * @memberof Netbanking
     */
    'netbanking_bank_code'?: number;
    /**
     * String code for bank
     * @type {string}
     * @memberof Netbanking
     */
    'netbanking_bank_name'?: string;
}
/**
 * returns all offers
 * @export
 * @interface OfferAll
 */
export interface OfferAll {
    /**
     * All offers applicable
     * @type {object}
     * @memberof OfferAll
     */
    'all': object;
}
/**
 * Offers related to cards
 * @export
 * @interface OfferCard
 */
export interface OfferCard {
    /**
     * 
     * @type {CardOffer}
     * @memberof OfferCard
     */
    'card': CardOffer;
}
/**
 * Offer details and type
 * @export
 * @interface OfferDetails
 */
export interface OfferDetails {
    /**
     * Offer Type for the Offer.
     * @type {string}
     * @memberof OfferDetails
     */
    'offer_type': OfferDetailsOfferTypeEnum;
    /**
     * 
     * @type {DiscountDetails}
     * @memberof OfferDetails
     */
    'discount_details'?: DiscountDetails;
    /**
     * 
     * @type {CashbackDetails}
     * @memberof OfferDetails
     */
    'cashback_details'?: CashbackDetails;
}

export const OfferDetailsOfferTypeEnum = {
    DISCOUNT: 'DISCOUNT',
    CASHBACK: 'CASHBACK',
    DISCOUNT_AND_CASHBACK: 'DISCOUNT_AND_CASHBACK',
    NO_COST_EMI: 'NO_COST_EMI',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type OfferDetailsOfferTypeEnum = typeof OfferDetailsOfferTypeEnum[keyof typeof OfferDetailsOfferTypeEnum];

/**
 * EMI offer object
 * @export
 * @interface OfferEMI
 */
export interface OfferEMI {
    /**
     * 
     * @type {EMIOffer}
     * @memberof OfferEMI
     */
    'emi': EMIOffer;
}
/**
 * Offer entity object
 * @export
 * @interface OfferEntity
 */
export interface OfferEntity {
    /**
     * 
     * @type {string}
     * @memberof OfferEntity
     */
    'offer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferEntity
     */
    'offer_status'?: string;
    /**
     * 
     * @type {OfferMeta}
     * @memberof OfferEntity
     */
    'offer_meta'?: OfferMeta;
    /**
     * 
     * @type {OfferTnc}
     * @memberof OfferEntity
     */
    'offer_tnc'?: OfferTnc;
    /**
     * 
     * @type {OfferDetails}
     * @memberof OfferEntity
     */
    'offer_details'?: OfferDetails;
    /**
     * 
     * @type {OfferValidations}
     * @memberof OfferEntity
     */
    'offer_validations'?: OfferValidations;
}
/**
 * Filter for offers
 * @export
 * @interface OfferFilters
 */
export interface OfferFilters {
    /**
     * Array of offer_type to be filtered.
     * @type {Array<OfferType>}
     * @memberof OfferFilters
     */
    'offer_type'?: Array<OfferType>;
}
/**
 * Offer meta details object
 * @export
 * @interface OfferMeta
 */
export interface OfferMeta {
    /**
     * Title for the Offer.
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_title': string;
    /**
     * Description for the Offer.
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_description': string;
    /**
     * Unique identifier for the Offer.
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_code': string;
    /**
     * Start Time for the Offer
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_start_time': string;
    /**
     * Expiry Time for the Offer
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_end_time': string;
}
/**
 * Offer object ofr NetBanking
 * @export
 * @interface OfferNB
 */
export interface OfferNB {
    /**
     * 
     * @type {OfferNBNetbanking}
     * @memberof OfferNB
     */
    'netbanking': OfferNBNetbanking;
}
/**
 * 
 * @export
 * @interface OfferNBNetbanking
 */
export interface OfferNBNetbanking {
    /**
     * 
     * @type {string}
     * @memberof OfferNBNetbanking
     */
    'bank_name'?: string;
}
/**
 * Offer object for paylater
 * @export
 * @interface OfferPaylater
 */
export interface OfferPaylater {
    /**
     * 
     * @type {PaylaterOffer}
     * @memberof OfferPaylater
     */
    'paylater': PaylaterOffer;
}
/**
 * Offer Query Object
 * @export
 * @interface OfferQueries
 */
export interface OfferQueries {
    /**
     * OrderId of the order. Either of `order_id` or `order_amount` is mandatory.
     * @type {string}
     * @memberof OfferQueries
     */
    'order_id'?: string;
    /**
     * Amount of the order. OrderId of the order. Either of `order_id` or `order_amount` is mandatory.
     * @type {number}
     * @memberof OfferQueries
     */
    'amount'?: number;
}
/**
 * Offer terms and condition object
 * @export
 * @interface OfferTnc
 */
export interface OfferTnc {
    /**
     * TnC Type for the Offer. It can be either `text` or `link`
     * @type {string}
     * @memberof OfferTnc
     */
    'offer_tnc_type': OfferTncOfferTncTypeEnum;
    /**
     * TnC for the Offer.
     * @type {string}
     * @memberof OfferTnc
     */
    'offer_tnc_value': string;
}

export const OfferTncOfferTncTypeEnum = {
    TEXT: 'text',
    LINK: 'link',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type OfferTncOfferTncTypeEnum = typeof OfferTncOfferTncTypeEnum[keyof typeof OfferTncOfferTncTypeEnum];

/**
 * Offer Type Object
 * @export
 * @enum {string}
 */

export const OfferType = {
    DISCOUNT: 'DISCOUNT',
    CASHBACK: 'CASHBACK',
    DISCOUNT_AND_CASHBACK: 'DISCOUNT_AND_CASHBACK',
    NO_COST_EMI: 'NO_COST_EMI',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type OfferType = typeof OfferType[keyof typeof OfferType];


/**
 * Offer object for UPI
 * @export
 * @interface OfferUPI
 */
export interface OfferUPI {
    /**
     * 
     * @type {object}
     * @memberof OfferUPI
     */
    'upi': object;
}
/**
 * Offer validation object
 * @export
 * @interface OfferValidations
 */
export interface OfferValidations {
    /**
     * Minimum Amount for Offer to be Applicable
     * @type {number}
     * @memberof OfferValidations
     */
    'min_amount'?: number;
    /**
     * Maximum Amount for Offer to be Applicable
     * @type {number}
     * @memberof OfferValidations
     */
    'max_allowed': number;
    /**
     * 
     * @type {OfferValidationsPaymentMethod}
     * @memberof OfferValidations
     */
    'payment_method': OfferValidationsPaymentMethod;
}
/**
 * @type OfferValidationsPaymentMethod
 * @export
 */
export type OfferValidationsPaymentMethod = OfferAll | OfferCard | OfferEMI | OfferNB | OfferPaylater | OfferUPI | OfferWallet;

/**
 * Offer object for wallet payment method
 * @export
 * @interface OfferWallet
 */
export interface OfferWallet {
    /**
     * 
     * @type {WalletOffer}
     * @memberof OfferWallet
     */
    'app': WalletOffer;
}
/**
 * This is the response shared when merchant inovkes the OTP submit or resend API
 * @export
 * @interface OrderAuthenticateEntity
 */
export interface OrderAuthenticateEntity {
    /**
     * The payment id for which this request was sent
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'cf_payment_id'?: string;
    /**
     * The action that was invoked for this request.
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'action'?: OrderAuthenticateEntityActionEnum;
    /**
     * Status of the is action. Will be either failed or successful. If the action is successful, you should still call the authorization status to verify the final payment status.
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'authenticate_status'?: OrderAuthenticateEntityAuthenticateStatusEnum;
    /**
     * Human readable message which describes the status in more detail
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'payment_message'?: string;
}

export const OrderAuthenticateEntityActionEnum = {
    SUBMIT_OTP: 'SUBMIT_OTP',
    RESEND_OTP: 'RESEND_OTP',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type OrderAuthenticateEntityActionEnum = typeof OrderAuthenticateEntityActionEnum[keyof typeof OrderAuthenticateEntityActionEnum];
export const OrderAuthenticateEntityAuthenticateStatusEnum = {
    FAILED: 'FAILED',
    SUCCESS: 'SUCCESS',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type OrderAuthenticateEntityAuthenticateStatusEnum = typeof OrderAuthenticateEntityAuthenticateStatusEnum[keyof typeof OrderAuthenticateEntityAuthenticateStatusEnum];

/**
 * OTP to be submitted for headless/native OTP
 * @export
 * @interface OrderAuthenticatePaymentRequest
 */
export interface OrderAuthenticatePaymentRequest {
    /**
     * OTP to be submitted
     * @type {string}
     * @memberof OrderAuthenticatePaymentRequest
     */
    'otp': string;
    /**
     * The action for this workflow. Could be either SUBMIT_OTP or RESEND_OTP
     * @type {string}
     * @memberof OrderAuthenticatePaymentRequest
     */
    'action': OrderAuthenticatePaymentRequestActionEnum;
}

export const OrderAuthenticatePaymentRequestActionEnum = {
    SUBMIT_OTP: 'SUBMIT_OTP',
    RESEND_OTP: 'RESEND_OTP',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type OrderAuthenticatePaymentRequestActionEnum = typeof OrderAuthenticatePaymentRequestActionEnum[keyof typeof OrderAuthenticatePaymentRequestActionEnum];

/**
 * create refund request object
 * @export
 * @interface OrderCreateRefundRequest
 */
export interface OrderCreateRefundRequest {
    /**
     * Amount to be refunded. Should be lesser than or equal to the transaction amount. (Decimals allowed)
     * @type {number}
     * @memberof OrderCreateRefundRequest
     */
    'refund_amount': number;
    /**
     * An unique ID to associate the refund with. Provie alphanumeric values
     * @type {string}
     * @memberof OrderCreateRefundRequest
     */
    'refund_id': string;
    /**
     * A refund note for your reference.
     * @type {string}
     * @memberof OrderCreateRefundRequest
     */
    'refund_note'?: string;
    /**
     * Speed at which the refund is processed. It\'s an optional field with default being STANDARD
     * @type {string}
     * @memberof OrderCreateRefundRequest
     */
    'refund_speed'?: OrderCreateRefundRequestRefundSpeedEnum;
    /**
     * 
     * @type {Array<VendorSplit>}
     * @memberof OrderCreateRefundRequest
     */
    'refund_splits'?: Array<VendorSplit>;
}

export const OrderCreateRefundRequestRefundSpeedEnum = {
    STANDARD: 'STANDARD',
    INSTANT: 'INSTANT',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type OrderCreateRefundRequestRefundSpeedEnum = typeof OrderCreateRefundRequestRefundSpeedEnum[keyof typeof OrderCreateRefundRequestRefundSpeedEnum];

/**
 * The complete order entity
 * @export
 * @interface OrderEntity
 */
export interface OrderEntity {
    /**
     * unique id generated by cashfree for your order
     * @type {string}
     * @memberof OrderEntity
     */
    'cf_order_id'?: string;
    /**
     * order_id sent during the api request
     * @type {string}
     * @memberof OrderEntity
     */
    'order_id'?: string;
    /**
     * Type of the entity.
     * @type {string}
     * @memberof OrderEntity
     */
    'entity'?: string;
    /**
     * Currency of the order. Example INR
     * @type {string}
     * @memberof OrderEntity
     */
    'order_currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderEntity
     */
    'order_amount'?: number;
    /**
     * Possible values are  - `ACTIVE`: Order does not have a sucessful transaction yet - `PAID`: Order is PAID with one successful transaction - `EXPIRED`: Order was not PAID and not it has expired. No transaction can be initiated for an EXPIRED order. `TERMINATED`: Order terminated `TERMINATION_REQUESTED`: Order termination requested
     * @type {string}
     * @memberof OrderEntity
     */
    'order_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderEntity
     */
    'payment_session_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderEntity
     */
    'order_expiry_time'?: string;
    /**
     * Additional note for order
     * @type {string}
     * @memberof OrderEntity
     */
    'order_note'?: string;
    /**
     * When the order was created at cashfree\'s server
     * @type {string}
     * @memberof OrderEntity
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<VendorSplit>}
     * @memberof OrderEntity
     */
    'order_splits'?: Array<VendorSplit>;
    /**
     * 
     * @type {CustomerDetails}
     * @memberof OrderEntity
     */
    'customer_details'?: CustomerDetails;
    /**
     * 
     * @type {OrderMeta}
     * @memberof OrderEntity
     */
    'order_meta'?: OrderMeta;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof OrderEntity
     */
    'order_tags'?: { [key: string]: string; };
}
/**
 * Optional meta details to control how the customer pays and how payment journey completes
 * @export
 * @interface OrderMeta
 */
export interface OrderMeta {
    /**
     * The URL to which user will be redirected to after the payment on bank OTP page. Maximum length: 250. We suggest to keep context of order_id in your return_url so that you can identify the order when customer lands on your page. Example of return_url format could be https://example.com/return?order_id=myOrderId
     * @type {string}
     * @memberof OrderMeta
     */
    'return_url'?: string;
    /**
     * Notification URL for server-server communication. Useful when user\'s connection drops while re-directing. NotifyUrl should be an https URL. Maximum length: 250.
     * @type {string}
     * @memberof OrderMeta
     */
    'notify_url'?: string;
    /**
     * Allowed payment modes for this order. Pass comma-separated values among following options - \"cc\", \"dc\", \"ccc\", \"ppc\",\"nb\",\"upi\",\"paypal\",\"app\",\"paylater\",\"cardlessemi\",\"dcemi\",\"ccemi\",\"banktransfer\". Leave it blank to show all available payment methods
     * @type {any}
     * @memberof OrderMeta
     */
    'payment_methods'?: any;
}
/**
 * the data object pay api
 * @export
 * @interface OrderPayData
 */
export interface OrderPayData {
    /**
     * 
     * @type {string}
     * @memberof OrderPayData
     */
    'url'?: string;
    /**
     * 
     * @type {object}
     * @memberof OrderPayData
     */
    'payload'?: object;
    /**
     * 
     * @type {string}
     * @memberof OrderPayData
     */
    'content_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderPayData
     */
    'method'?: string;
}
/**
 * Order Pay response once you create a transaction for that order
 * @export
 * @interface PayOrderEntity
 */
export interface PayOrderEntity {
    /**
     * total amount payable
     * @type {number}
     * @memberof PayOrderEntity
     */
    'payment_amount'?: number;
    /**
     * Payment identifier created by Cashfree
     * @type {string}
     * @memberof PayOrderEntity
     */
    'cf_payment_id'?: string;
    /**
     * One of [\"upi\", \"netbanking\", \"card\", \"app\", \"cardless_emi\", \"paylater\", \"banktransfer\"] 
     * @type {string}
     * @memberof PayOrderEntity
     */
    'payment_method'?: PayOrderEntityPaymentMethodEnum;
    /**
     * One of [\"link\", \"collect\", \"qrcode\"]. In an older version we used to support different channels like \'gpay\', \'phonepe\' etc. However, we now support only the following channels - link, collect and qrcode. To process payments using gpay, you will have to provide channel as \'link\' and provider as \'gpay\'
     * @type {string}
     * @memberof PayOrderEntity
     */
    'channel'?: PayOrderEntityChannelEnum;
    /**
     * One of [\"link\", \"custom\", \"form\"]
     * @type {string}
     * @memberof PayOrderEntity
     */
    'action'?: PayOrderEntityActionEnum;
    /**
     * 
     * @type {OrderPayData}
     * @memberof PayOrderEntity
     */
    'data'?: OrderPayData;
}

export const PayOrderEntityPaymentMethodEnum = {
    NETBANKING: 'netbanking',
    CARD: 'card',
    UPI: 'upi',
    APP: 'app',
    CARDLESS_EMI: 'cardless_emi',
    PAYLATER: 'paylater',
    BANKTRANSFER: 'banktransfer',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type PayOrderEntityPaymentMethodEnum = typeof PayOrderEntityPaymentMethodEnum[keyof typeof PayOrderEntityPaymentMethodEnum];
export const PayOrderEntityChannelEnum = {
    LINK: 'link',
    COLLECT: 'collect',
    QRCODE: 'qrcode',
    POST: 'post',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type PayOrderEntityChannelEnum = typeof PayOrderEntityChannelEnum[keyof typeof PayOrderEntityChannelEnum];
export const PayOrderEntityActionEnum = {
    LINK: 'link',
    CUSTOM: 'custom',
    FORM: 'form',
    POST: 'post',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type PayOrderEntityActionEnum = typeof PayOrderEntityActionEnum[keyof typeof PayOrderEntityActionEnum];

/**
 * Complete object for the pay api that uses payment method objects
 * @export
 * @interface PayOrderRequest
 */
export interface PayOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof PayOrderRequest
     */
    'payment_session_id': string;
    /**
     * 
     * @type {PayOrderRequestPaymentMethod}
     * @memberof PayOrderRequest
     */
    'payment_method': PayOrderRequestPaymentMethod;
    /**
     * 
     * @type {boolean}
     * @memberof PayOrderRequest
     */
    'save_instrument'?: boolean;
    /**
     * This is required if any offers needs to be applied to the order.
     * @type {string}
     * @memberof PayOrderRequest
     */
    'offer_id'?: string;
}
/**
 * @type PayOrderRequestPaymentMethod
 * @export
 */
export type PayOrderRequestPaymentMethod = AppPaymentMethod | BanktransferPaymentMethod | CardEMIPaymentMethod | CardPaymentMethod | CardlessEMIPaymentMethod | NetBankingPaymentMethod | PaylaterPaymentMethod | UPIPaymentMethod;

/**
 * Paylater payment method
 * @export
 * @interface Paylater
 */
export interface Paylater {
    /**
     * The channel for cardless EMI is always `link`
     * @type {string}
     * @memberof Paylater
     */
    'channel'?: string;
    /**
     * One of [\"kotak\", \"flexipay\", \"zestmoney\", \"lazypay\", \"olapostpaid\",\"simpl\", \"freechargepaylater\"]. Please note that Flexipay is offered by HDFC bank
     * @type {string}
     * @memberof Paylater
     */
    'provider'?: PaylaterProviderEnum;
    /**
     * Customers phone number for this payment instrument. If the customer is not eligible you will receive a 400 error with type as \'invalid_request_error\' and code as \'invalid_request_error\'
     * @type {string}
     * @memberof Paylater
     */
    'phone'?: string;
}

export const PaylaterProviderEnum = {
    KOTAK: 'kotak',
    FLEXIPAY: 'flexipay',
    ZESTMONEY: 'zestmoney',
    LAZYPAY: 'lazypay',
    OLAPOSTPAID: 'olapostpaid',
    SIMPL: 'simpl',
    FREECHARGEPAYLATER: 'freechargepaylater',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type PaylaterProviderEnum = typeof PaylaterProviderEnum[keyof typeof PaylaterProviderEnum];

/**
 * Paylater Entity
 * @export
 * @interface PaylaterEntity
 */
export interface PaylaterEntity {
    /**
     * 
     * @type {string}
     * @memberof PaylaterEntity
     */
    'payment_method'?: string;
}
/**
 * 
 * @export
 * @interface PaylaterOffer
 */
export interface PaylaterOffer {
    /**
     * 
     * @type {string}
     * @memberof PaylaterOffer
     */
    'provider'?: string;
}
/**
 * paylater payment method
 * @export
 * @interface PaylaterPaymentMethod
 */
export interface PaylaterPaymentMethod {
    /**
     * 
     * @type {Paylater}
     * @memberof PaylaterPaymentMethod
     */
    'paylater': Paylater;
}
/**
 * payment entity full object
 * @export
 * @interface PaymentEntity
 */
export interface PaymentEntity {
    /**
     * 
     * @type {string}
     * @memberof PaymentEntity
     */
    'cf_payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentEntity
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentEntity
     */
    'entity'?: string;
    /**
     * 
     * @type {ErrorDetailsInPaymentsEntity}
     * @memberof PaymentEntity
     */
    'error_details'?: ErrorDetailsInPaymentsEntity;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentEntity
     */
    'is_captured'?: boolean;
    /**
     * Order amount can be different from payment amount if you collect service fee from the customer
     * @type {number}
     * @memberof PaymentEntity
     */
    'order_amount'?: number;
    /**
     * Type of payment group. One of [\'prepaid_card\', \'upi_ppi_offline\', \'cash\', \'upi_credit_card\', \'paypal\', \'net_banking\', \'cardless_emi\', \'credit_card\', \'bank_transfer\', \'pay_later\', \'debit_card_emi\', \'debit_card\', \'wallet\', \'upi_ppi\', \'upi\', \'credit_card_emi\']
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentEntity
     */
    'payment_amount'?: number;
    /**
     * This is the time when the payment was initiated
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_time'?: string;
    /**
     * This is the time when the payment reaches its terminal state
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_completion_time'?: string;
    /**
     * The transaction status can be one of  [\"SUCCESS\", \"NOT_ATTEMPTED\", \"FAILED\", \"USER_DROPPED\", \"VOID\", \"CANCELLED\", \"PENDING\"]
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_status'?: PaymentEntityPaymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentEntity
     */
    'bank_reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentEntity
     */
    'auth_id'?: string;
    /**
     * 
     * @type {AuthorizationInPaymentsEntity}
     * @memberof PaymentEntity
     */
    'authorization'?: AuthorizationInPaymentsEntity;
    /**
     * 
     * @type {PaymentEntityPaymentMethod}
     * @memberof PaymentEntity
     */
    'payment_method'?: PaymentEntityPaymentMethod;
}

export const PaymentEntityPaymentStatusEnum = {
    SUCCESS: 'SUCCESS',
    NOT_ATTEMPTED: 'NOT_ATTEMPTED',
    FAILED: 'FAILED',
    USER_DROPPED: 'USER_DROPPED',
    VOID: 'VOID',
    CANCELLED: 'CANCELLED',
    PENDING: 'PENDING',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type PaymentEntityPaymentStatusEnum = typeof PaymentEntityPaymentStatusEnum[keyof typeof PaymentEntityPaymentStatusEnum];

/**
 * @type PaymentEntityPaymentMethod
 * @export
 */
export type PaymentEntityPaymentMethod = PaymentMethodAppInPaymentsEntity | PaymentMethodBankTransferInPaymentsEntity | PaymentMethodCardEMIInPaymentsEntity | PaymentMethodCardInPaymentsEntity | PaymentMethodCardlessEMIInPaymentsEntity | PaymentMethodNetBankingInPaymentsEntity | PaymentMethodPaylaterInPaymentsEntity | PaymentMethodUPIInPaymentsEntity;

/**
 * The customer details that are necessary. Note that you can pass dummy details if your use case does not require the customer details.
 * @export
 * @interface PaymentLinkCustomerDetails
 */
export interface PaymentLinkCustomerDetails {
    /**
     * A unique identifier for the customer. Use alphanumeric values only.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_id'?: string;
    /**
     * Customer email address.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_email'?: string;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_phone': string;
    /**
     * Name of the customer.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_name'?: string;
    /**
     * Customer bank account. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_bank_account_number'?: string;
    /**
     * Customer bank IFSC. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_bank_ifsc'?: string;
    /**
     * Customer bank code. Required for net banking payments, if you want to do a bank account check (TPV)
     * @type {number}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_bank_code'?: number;
}
/**
 * The complete order entity
 * @export
 * @interface PaymentLinkOrderEntity
 */
export interface PaymentLinkOrderEntity {
    /**
     * unique id generated by cashfree for your order
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'cf_order_id'?: string;
    /**
     * link id of the order
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'link_id'?: string;
    /**
     * order_id sent during the api request
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_id'?: string;
    /**
     * Type of the entity.
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'entity'?: string;
    /**
     * Currency of the order. Example INR
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentLinkOrderEntity
     */
    'order_amount'?: number;
    /**
     * Possible values are  - `ACTIVE`: Order does not have a sucessful transaction yet - `PAID`: Order is PAID with one successful transaction - `EXPIRED`: Order was not PAID and not it has expired. No transaction can be initiated for an EXPIRED order. 
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'payment_session_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_expiry_time'?: string;
    /**
     * Additional note for order
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_note'?: string;
    /**
     * When the order was created at cashfree\'s server
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<VendorSplit>}
     * @memberof PaymentLinkOrderEntity
     */
    'order_splits'?: Array<VendorSplit>;
    /**
     * 
     * @type {PaymentLinkCustomerDetails}
     * @memberof PaymentLinkOrderEntity
     */
    'customer_details'?: PaymentLinkCustomerDetails;
    /**
     * 
     * @type {OrderMeta}
     * @memberof PaymentLinkOrderEntity
     */
    'order_meta'?: OrderMeta;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof PaymentLinkOrderEntity
     */
    'order_tags'?: { [key: string]: string; };
}
/**
 * payment method app object in payment entity
 * @export
 * @interface PaymentMethodAppInPaymentsEntity
 */
export interface PaymentMethodAppInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodAppInPaymentsEntityApp}
     * @memberof PaymentMethodAppInPaymentsEntity
     */
    'app'?: PaymentMethodAppInPaymentsEntityApp;
}
/**
 * 
 * @export
 * @interface PaymentMethodAppInPaymentsEntityApp
 */
export interface PaymentMethodAppInPaymentsEntityApp {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodAppInPaymentsEntityApp
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodAppInPaymentsEntityApp
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodAppInPaymentsEntityApp
     */
    'phone'?: string;
}
/**
 * payment method bank transfer object in payment entity
 * @export
 * @interface PaymentMethodBankTransferInPaymentsEntity
 */
export interface PaymentMethodBankTransferInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodBankTransferInPaymentsEntityBanktransfer}
     * @memberof PaymentMethodBankTransferInPaymentsEntity
     */
    'banktransfer'?: PaymentMethodBankTransferInPaymentsEntityBanktransfer;
}
/**
 * 
 * @export
 * @interface PaymentMethodBankTransferInPaymentsEntityBanktransfer
 */
export interface PaymentMethodBankTransferInPaymentsEntityBanktransfer {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBankTransferInPaymentsEntityBanktransfer
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBankTransferInPaymentsEntityBanktransfer
     */
    'banktransfer_bank_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBankTransferInPaymentsEntityBanktransfer
     */
    'banktransfer_ifsc'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBankTransferInPaymentsEntityBanktransfer
     */
    'banktransfer_account_number'?: string;
}
/**
 * payment method card emi object in payment entity
 * @export
 * @interface PaymentMethodCardEMIInPaymentsEntity
 */
export interface PaymentMethodCardEMIInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodCardEMIInPaymentsEntityEmi}
     * @memberof PaymentMethodCardEMIInPaymentsEntity
     */
    'emi'?: PaymentMethodCardEMIInPaymentsEntityEmi;
}
/**
 * 
 * @export
 * @interface PaymentMethodCardEMIInPaymentsEntityEmi
 */
export interface PaymentMethodCardEMIInPaymentsEntityEmi {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_network'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_bank_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_network_reference_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'emi_tenure'?: number;
    /**
     * 
     * @type {PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'emi_details'?: PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails;
}
/**
 * 
 * @export
 * @interface PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
 */
export interface PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails {
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
     */
    'emi_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
     */
    'emi_tenure'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
     */
    'emi_interest'?: number;
}
/**
 * payment method card object in payment entity
 * @export
 * @interface PaymentMethodCardInPaymentsEntity
 */
export interface PaymentMethodCardInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodCardInPaymentsEntityCard}
     * @memberof PaymentMethodCardInPaymentsEntity
     */
    'card'?: PaymentMethodCardInPaymentsEntityCard;
}
/**
 * 
 * @export
 * @interface PaymentMethodCardInPaymentsEntityCard
 */
export interface PaymentMethodCardInPaymentsEntityCard {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_network'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_bank_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_network_reference_id'?: string;
}
/**
 * payment method carless object in payment entity
 * @export
 * @interface PaymentMethodCardlessEMIInPaymentsEntity
 */
export interface PaymentMethodCardlessEMIInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodAppInPaymentsEntityApp}
     * @memberof PaymentMethodCardlessEMIInPaymentsEntity
     */
    'cardless_emi'?: PaymentMethodAppInPaymentsEntityApp;
}
/**
 * netbanking payment method object for pay
 * @export
 * @interface PaymentMethodNetBankingInPaymentsEntity
 */
export interface PaymentMethodNetBankingInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodNetBankingInPaymentsEntityNetbanking}
     * @memberof PaymentMethodNetBankingInPaymentsEntity
     */
    'netbanking'?: PaymentMethodNetBankingInPaymentsEntityNetbanking;
}
/**
 * 
 * @export
 * @interface PaymentMethodNetBankingInPaymentsEntityNetbanking
 */
export interface PaymentMethodNetBankingInPaymentsEntityNetbanking {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'channel'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_bank_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_bank_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_ifsc'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_account_number'?: string;
}
/**
 * paylater payment method object for pay api
 * @export
 * @interface PaymentMethodPaylaterInPaymentsEntity
 */
export interface PaymentMethodPaylaterInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodAppInPaymentsEntityApp}
     * @memberof PaymentMethodPaylaterInPaymentsEntity
     */
    'paylater'?: PaymentMethodAppInPaymentsEntityApp;
}
/**
 * UPI payment method for pay api
 * @export
 * @interface PaymentMethodUPIInPaymentsEntity
 */
export interface PaymentMethodUPIInPaymentsEntity {
    /**
     * 
     * @type {PaymentMethodUPIInPaymentsEntityUpi}
     * @memberof PaymentMethodUPIInPaymentsEntity
     */
    'upi'?: PaymentMethodUPIInPaymentsEntityUpi;
}
/**
 * 
 * @export
 * @interface PaymentMethodUPIInPaymentsEntityUpi
 */
export interface PaymentMethodUPIInPaymentsEntityUpi {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodUPIInPaymentsEntityUpi
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodUPIInPaymentsEntityUpi
     */
    'upi_id'?: string;
}
/**
 * Filter for Payment Methods
 * @export
 * @interface PaymentMethodsFilters
 */
export interface PaymentMethodsFilters {
    /**
     * Array of payment methods to be filtered. This is optional, by default all payment methods will be returned. Possible values in [ \'debit_card\', \'credit_card\', \'prepaid_card\', \'corporate_credit_card\', \'upi\', \'wallet\', \'netbanking\', \'banktransfer\', \'paylater\', \'paypal\', \'debit_card_emi\', \'credit_card_emi\', \'upi_credit_card\', \'upi_ppi\', \'cardless_emi\', \'account_based_payment\' ] 
     * @type {Array<string>}
     * @memberof PaymentMethodsFilters
     */
    'payment_methods'?: Array<string>;
}
/**
 * Payment Method Query Object
 * @export
 * @interface PaymentMethodsQueries
 */
export interface PaymentMethodsQueries {
    /**
     * Amount of the order.
     * @type {number}
     * @memberof PaymentMethodsQueries
     */
    'amount'?: number;
    /**
     * OrderId of the order. Either of `order_id` or `order_amount` is mandatory.
     * @type {string}
     * @memberof PaymentMethodsQueries
     */
    'order_id'?: string;
}
/**
 * payment mode eligiblity object
 * @export
 * @interface PaymentModeDetails
 */
export interface PaymentModeDetails {
    /**
     * 
     * @type {string}
     * @memberof PaymentModeDetails
     */
    'nick'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentModeDetails
     */
    'display'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentModeDetails
     */
    'eligibility'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PaymentModeDetails
     */
    'code'?: number;
}
/**
 * payment webhook object
 * @export
 * @interface PaymentWebhook
 */
export interface PaymentWebhook {
    /**
     * 
     * @type {PaymentWebhookDataEntity}
     * @memberof PaymentWebhook
     */
    'data'?: PaymentWebhookDataEntity;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhook
     */
    'event_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhook
     */
    'type'?: string;
}
/**
 * customer details object in webhook
 * @export
 * @interface PaymentWebhookCustomerEntity
 */
export interface PaymentWebhookCustomerEntity {
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_phone'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface PaymentWebhookDataEntity
 */
export interface PaymentWebhookDataEntity {
    /**
     * 
     * @type {PaymentWebhookOrderEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'order'?: PaymentWebhookOrderEntity;
    /**
     * 
     * @type {PaymentEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'payment'?: PaymentEntity;
    /**
     * 
     * @type {PaymentWebhookCustomerEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'customer_details'?: PaymentWebhookCustomerEntity;
    /**
     * 
     * @type {PaymentWebhookErrorEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'error_details'?: PaymentWebhookErrorEntity;
    /**
     * 
     * @type {PaymentWebhookGatewayDetailsEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'payment_gateway_details'?: PaymentWebhookGatewayDetailsEntity;
    /**
     * 
     * @type {Array<OfferEntity>}
     * @memberof PaymentWebhookDataEntity
     */
    'payment_offers'?: Array<OfferEntity>;
}
/**
 * error details present in the webhook
 * @export
 * @interface PaymentWebhookErrorEntity
 */
export interface PaymentWebhookErrorEntity {
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_source'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_code_raw'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_description_raw'?: string;
}
/**
 * payment gatewat details present in the webhook response
 * @export
 * @interface PaymentWebhookGatewayDetailsEntity
 */
export interface PaymentWebhookGatewayDetailsEntity {
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_status_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_settlement'?: string;
}
/**
 * order entity in webhook
 * @export
 * @interface PaymentWebhookOrderEntity
 */
export interface PaymentWebhookOrderEntity {
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_currency'?: string;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_tags'?: { [key: string]: string; };
}
/**
 * Error when rate limit is breached for your api
 * @export
 * @interface RateLimitError
 */
export interface RateLimitError {
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'code'?: string;
    /**
     * rate_limit_error
     * @type {string}
     * @memberof RateLimitError
     */
    'type'?: RateLimitErrorTypeEnum;
}

export const RateLimitErrorTypeEnum = {
    RATE_LIMIT_ERROR: 'rate_limit_error',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type RateLimitErrorTypeEnum = typeof RateLimitErrorTypeEnum[keyof typeof RateLimitErrorTypeEnum];

/**
 * Settlement detailed recon response
 * @export
 * @interface ReconEntity
 */
export interface ReconEntity {
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof ReconEntity
     */
    'cursor'?: string;
    /**
     * Number of settlements you want to fetch in the next iteration.
     * @type {number}
     * @memberof ReconEntity
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<ReconEntityDataInner>}
     * @memberof ReconEntity
     */
    'data'?: Array<ReconEntityDataInner>;
}
/**
 * 
 * @export
 * @interface ReconEntityDataInner
 */
export interface ReconEntityDataInner {
    /**
     * Unique ID associated with the event.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_id'?: string;
    /**
     * The event type can be SETTLEMENT, PAYMENT, REFUND, REFUND_REVERSAL, DISPUTE, DISPUTE_REVERSAL, CHARGEBACK, CHARGEBACK_REVERSAL, OTHER_ADJUSTMENT.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_type'?: string;
    /**
     * Amount that is part of the settlement corresponding to the event.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'event_settlement_amount'?: number;
    /**
     * Amount of the event. Example, refund amount, dispute amount, payment amount, etc.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'event_amount'?: number;
    /**
     * Indicates if it is CREDIT/DEBIT sale.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'sale_type'?: string;
    /**
     * Status of the event. Example - SUCCESS, FAILED, PENDING, CANCELLED.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_status'?: string;
    /**
     * Recon
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'entity'?: string;
    /**
     * Time associated with the event. Example, transaction time, dispute initiation time
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_time'?: string;
    /**
     * Curreny type - INR.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_currency'?: string;
    /**
     * Unique order ID. Alphanumeric and only \'-\' and \'_\' allowed.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'order_id'?: string;
    /**
     * The amount which was passed at the order creation time.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'order_amount'?: number;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'customer_phone'?: string;
    /**
     * Customer email.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'customer_email'?: string;
    /**
     * Customer name.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'customer_name'?: string;
    /**
     * Payment amount captured.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'payment_amount'?: number;
    /**
     * Unique transaction reference number of the payment.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_utr'?: string;
    /**
     * Date and time when the payment was initiated.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_time'?: string;
    /**
     * Service charge applicable for the payment.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'payment_service_charge'?: number;
    /**
     * Service tax applicable on the payment.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'payment_service_tax'?: number;
    /**
     * Cashfree Payments unique ID to identify a payment.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'cf_payment_id'?: string;
    /**
     * Unique ID to identify the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'cf_settlement_id'?: string;
    /**
     * Date and time when the settlement was processed.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_date'?: string;
    /**
     * Unique transaction reference number of the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_utr'?: string;
    /**
     * Service charge that is applicable for splitting the payment.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'split_service_charge'?: number;
    /**
     * Service tax applicable for splitting the amount to vendors.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'split_service_tax'?: number;
    /**
     * Vendor commission applicable for this transaction.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'vendor_commission'?: number;
    /**
     * Specifies whether the dispute was closed in favor of the merchant or customer. /n Possible values - Merchant, Customer
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'closed_in_favor_of'?: string;
    /**
     * Date and time when the dispute was resolved.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'dispute_resolved_on'?: string;
    /**
     * Category of the dispute - Dispute code and the reason for dispute is shown.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'dispute_category'?: string;
    /**
     * Note regarding the dispute.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'dispute_note'?: string;
    /**
     * Date and time when the refund was processed.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_processed_at'?: string;
    /**
     * The bank reference number for the refund.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_arn'?: string;
    /**
     * A refund note for your reference.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_note'?: string;
    /**
     * An unique ID to associate the refund with.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_id'?: string;
    /**
     * Other adjustment remarks.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'adjustment_remarks'?: string;
    /**
     * Amount that is adjusted from the settlement amount because of any credit/debit event such as refund, refund_reverse etc.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'adjustment'?: number;
    /**
     * Service tax applicable on the settlement amount.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'service_tax'?: number;
    /**
     * Service charge applicable on the settlement amount.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'service_charge'?: number;
    /**
     * Net amount that is settled after considering the adjustments, settlement charge and tax.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'amount_settled'?: number;
    /**
     * The start time of the time range of the payments considered for the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_from'?: string;
    /**
     * The end time of time range of the payments considered for the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_till'?: string;
    /**
     * Reason for settlement failure.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'reason'?: string;
    /**
     * Date and time when the settlement was initiated.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_initiated_on'?: string;
    /**
     * Type of settlement. Possible values - Standard, Instant, On demand.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_type'?: string;
    /**
     * Settlement charges applicable on the settlement.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'settlement_charge'?: number;
    /**
     * Settlement tax applicable on the settlement.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'settlement_tax'?: number;
    /**
     * Remarks on the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'remarks'?: string;
}
/**
 * The refund entity
 * @export
 * @interface RefundEntity
 */
export interface RefundEntity {
    /**
     * Cashfree Payments ID of the payment for which refund is initiated
     * @type {string}
     * @memberof RefundEntity
     */
    'cf_payment_id'?: string;
    /**
     * Cashfree Payments ID for a refund
     * @type {string}
     * @memberof RefundEntity
     */
    'cf_refund_id'?: string;
    /**
     * Merchant’s order Id of the order for which refund is initiated
     * @type {string}
     * @memberof RefundEntity
     */
    'order_id'?: string;
    /**
     * Merchant’s refund ID of the refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_id'?: string;
    /**
     * Type of object
     * @type {string}
     * @memberof RefundEntity
     */
    'entity'?: RefundEntityEntityEnum;
    /**
     * Amount that is refunded
     * @type {number}
     * @memberof RefundEntity
     */
    'refund_amount'?: number;
    /**
     * Currency of the refund amount
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_currency'?: string;
    /**
     * Note added by merchant for the refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_note'?: string;
    /**
     * This can be one of [\"SUCCESS\", \"PENDING\", \"CANCELLED\", \"ONHOLD\", \"FAILED\"]
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_status'?: RefundEntityRefundStatusEnum;
    /**
     * The bank reference number for refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_arn'?: string;
    /**
     * Charges in INR for processing refund
     * @type {number}
     * @memberof RefundEntity
     */
    'refund_charge'?: number;
    /**
     * Description of refund status
     * @type {string}
     * @memberof RefundEntity
     */
    'status_description'?: string;
    /**
     * Key-value pair that can be used to store additional information about the entity. Maximum 5 key-value pairs
     * @type {object}
     * @memberof RefundEntity
     */
    'metadata'?: object;
    /**
     * 
     * @type {Array<VendorSplit>}
     * @memberof RefundEntity
     */
    'refund_splits'?: Array<VendorSplit>;
    /**
     * This can be one of [\"PAYMENT_AUTO_REFUND\", \"MERCHANT_INITIATED\", \"UNRECONCILED_AUTO_REFUND\"]
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_type'?: RefundEntityRefundTypeEnum;
    /**
     * Method or speed of processing refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_mode'?: RefundEntityRefundModeEnum;
    /**
     * Time of refund creation
     * @type {string}
     * @memberof RefundEntity
     */
    'created_at'?: string;
    /**
     * Time when refund was processed successfully
     * @type {string}
     * @memberof RefundEntity
     */
    'processed_at'?: string;
    /**
     * 
     * @type {RefundSpeed}
     * @memberof RefundEntity
     */
    'refund_speed'?: RefundSpeed;
}

export const RefundEntityEntityEnum = {
    REFUND: 'refund',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type RefundEntityEntityEnum = typeof RefundEntityEntityEnum[keyof typeof RefundEntityEntityEnum];
export const RefundEntityRefundStatusEnum = {
    SUCCESS: 'SUCCESS',
    PENDING: 'PENDING',
    CANCELLED: 'CANCELLED',
    ONHOLD: 'ONHOLD',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type RefundEntityRefundStatusEnum = typeof RefundEntityRefundStatusEnum[keyof typeof RefundEntityRefundStatusEnum];
export const RefundEntityRefundTypeEnum = {
    PAYMENT_AUTO_REFUND: 'PAYMENT_AUTO_REFUND',
    MERCHANT_INITIATED: 'MERCHANT_INITIATED',
    UNRECONCILED_AUTO_REFUND: 'UNRECONCILED_AUTO_REFUND',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type RefundEntityRefundTypeEnum = typeof RefundEntityRefundTypeEnum[keyof typeof RefundEntityRefundTypeEnum];
export const RefundEntityRefundModeEnum = {
    STANDARD: 'STANDARD',
    INSTANT: 'INSTANT',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type RefundEntityRefundModeEnum = typeof RefundEntityRefundModeEnum[keyof typeof RefundEntityRefundModeEnum];

/**
 * How fast refund has to be proecessed
 * @export
 * @interface RefundSpeed
 */
export interface RefundSpeed {
    /**
     * Requested speed of refund.
     * @type {string}
     * @memberof RefundSpeed
     */
    'requested'?: string;
    /**
     * Accepted speed of refund.
     * @type {string}
     * @memberof RefundSpeed
     */
    'accepted'?: string;
    /**
     * Processed speed of refund.
     * @type {string}
     * @memberof RefundSpeed
     */
    'processed'?: string;
    /**
     * Error message, if any for refund_speed request
     * @type {string}
     * @memberof RefundSpeed
     */
    'message'?: string;
}
/**
 * refund webhook object
 * @export
 * @interface RefundWebhook
 */
export interface RefundWebhook {
    /**
     * 
     * @type {RefundWebhookDataEntity}
     * @memberof RefundWebhook
     */
    'data'?: RefundWebhookDataEntity;
    /**
     * 
     * @type {string}
     * @memberof RefundWebhook
     */
    'event_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundWebhook
     */
    'type'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface RefundWebhookDataEntity
 */
export interface RefundWebhookDataEntity {
    /**
     * 
     * @type {RefundEntity}
     * @memberof RefundWebhookDataEntity
     */
    'refund'?: RefundEntity;
}
/**
 * Card instrument meta information
 * @export
 * @interface SavedInstrumentMeta
 */
export interface SavedInstrumentMeta {
    /**
     * card scheme/network of the saved card. Example visa, mastercard
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_network'?: string;
    /**
     * Issuing bank name of saved card
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_bank_name'?: string;
    /**
     * Issuing country of saved card
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_country'?: string;
    /**
     * Type of saved card
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_type'?: string;
    /**
     * 
     * @type {object}
     * @memberof SavedInstrumentMeta
     */
    'card_token_details'?: object;
}
/**
 * 
 * @export
 * @interface ScheduleOption
 */
export interface ScheduleOption {
    /**
     * 
     * @type {string}
     * @memberof ScheduleOption
     */
    'settlement_schedule_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduleOption
     */
    'schedule_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleOption
     */
    'merchant_default'?: boolean;
}
/**
 * Settlement entity object
 * @export
 * @interface SettlementEntity
 */
export interface SettlementEntity {
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'cf_payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'cf_settlement_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'settlement_currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'entity'?: string;
    /**
     * 
     * @type {number}
     * @memberof SettlementEntity
     */
    'order_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'payment_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof SettlementEntity
     */
    'service_charge'?: number;
    /**
     * 
     * @type {number}
     * @memberof SettlementEntity
     */
    'service_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof SettlementEntity
     */
    'settlement_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SettlementEntity
     */
    'settlement_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SettlementEntity
     */
    'transfer_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'transfer_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementEntity
     */
    'transfer_utr'?: string;
}
/**
 * Recon Request Object
 * @export
 * @interface SettlementFetchReconRequest
 */
export interface SettlementFetchReconRequest {
    /**
     * 
     * @type {FetchSettlementsRequestPagination}
     * @memberof SettlementFetchReconRequest
     */
    'pagination': FetchSettlementsRequestPagination;
    /**
     * 
     * @type {FetchSettlementsRequestFilters}
     * @memberof SettlementFetchReconRequest
     */
    'filters': FetchSettlementsRequestFilters;
}
/**
 * Recon object for settlement
 * @export
 * @interface SettlementReconEntity
 */
export interface SettlementReconEntity {
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof SettlementReconEntity
     */
    'cursor'?: string;
    /**
     * Number of settlements you want to fetch in the next iteration.
     * @type {number}
     * @memberof SettlementReconEntity
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<SettlementReconEntityDataInner>}
     * @memberof SettlementReconEntity
     */
    'data'?: Array<SettlementReconEntityDataInner>;
}
/**
 * 
 * @export
 * @interface SettlementReconEntityDataInner
 */
export interface SettlementReconEntityDataInner {
    /**
     * Unique ID associated with the event.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_id'?: string;
    /**
     * The event type can be PAYMENT, REFUND, REFUND_REVERSAL, DISPUTE, DISPUTE_REVERSAL, CHARGEBACK, CHARGEBACK_REVERSAL, OTHER_ADJUSTMENT.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_type'?: string;
    /**
     * Amount that is part of the settlement corresponding to the event.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'event_settlement_amount'?: number;
    /**
     * Amount corresponding to the event. Example, refund amount, dispute amount, payment amount, etc.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'event_amount'?: number;
    /**
     * Indicates if it is CREDIT/DEBIT sale.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'sale_type'?: string;
    /**
     * Status of the event. Example - SUCCESS, FAILED, PENDING, CANCELLED.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_status'?: string;
    /**
     * Recon
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'entity'?: string;
    /**
     * Time associated with the event. Example, transaction time, dispute initiation time
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_time'?: string;
    /**
     * Curreny type - INR.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_currency'?: string;
    /**
     * Unique order ID. Alphanumeric and only \'-\' and \'_\' allowed.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'order_id'?: string;
    /**
     * The amount which was passed at the order creation time.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'order_amount'?: number;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'customer_phone'?: string;
    /**
     * Customer email.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'customer_email'?: string;
    /**
     * Customer name.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'customer_name'?: string;
    /**
     * Payment amount captured.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_amount'?: number;
    /**
     * Unique transaction reference number of the payment.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_utr'?: string;
    /**
     * Date and time when the payment was initiated.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_time'?: string;
    /**
     * Service charge applicable for the payment.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_service_charge'?: number;
    /**
     * Service tax applicable on the payment.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_service_tax'?: number;
    /**
     * Cashfree Payments unique ID to identify a payment.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'cf_payment_id'?: string;
    /**
     * Unique ID to identify the settlement.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'cf_settlement_id'?: string;
    /**
     * Date and time when the settlement was processed.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'settlement_date'?: string;
    /**
     * Unique transaction reference number of the settlement.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'settlement_utr'?: string;
    /**
     * Service charge that is applicable for splitting the payment.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'split_service_charge'?: number;
    /**
     * Service tax applicable for splitting the amount to vendors.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'split_service_tax'?: number;
    /**
     * Vendor commission applicable for this transaction.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'vendor_commission'?: number;
    /**
     * Specifies whether the dispute was closed in favor of the merchant or customer. Possible values - Merchant, Customer.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'closed_in_favor_of'?: string;
    /**
     * Date and time when the dispute was resolved.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'dispute_resolved_on'?: string;
    /**
     * Category of the dispute - Dispute code and the reason for dispute is shown.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'dispute_category'?: string;
    /**
     * Note regarding the dispute.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'dispute_note'?: string;
    /**
     * Date and time when the refund was processed.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_processed_at'?: string;
    /**
     * The bank reference number for refund.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_arn'?: string;
    /**
     * A refund note for your reference.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_note'?: string;
    /**
     * An unique ID associated with the refund.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_id'?: string;
    /**
     * Other adjustment remarks.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'adjustment_remarks'?: string;
}
/**
 * Settlement webhook object
 * @export
 * @interface SettlementWebhook
 */
export interface SettlementWebhook {
    /**
     * 
     * @type {SettlementWebhookDataEntity}
     * @memberof SettlementWebhook
     */
    'data'?: SettlementWebhookDataEntity;
    /**
     * 
     * @type {string}
     * @memberof SettlementWebhook
     */
    'event_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementWebhook
     */
    'type'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface SettlementWebhookDataEntity
 */
export interface SettlementWebhookDataEntity {
    /**
     * 
     * @type {SettlementEntity}
     * @memberof SettlementWebhookDataEntity
     */
    'settlement'?: SettlementEntity;
}
/**
 * Split After Payment Request
 * @export
 * @interface SplitAfterPaymentRequest
 */
export interface SplitAfterPaymentRequest {
    /**
     * Specify the vendors order split details.
     * @type {Array<SplitAfterPaymentRequestSplitInner>}
     * @memberof SplitAfterPaymentRequest
     */
    'split': Array<SplitAfterPaymentRequestSplitInner>;
    /**
     * Specify if you want to end the split or continue creating further splits in future.
     * @type {boolean}
     * @memberof SplitAfterPaymentRequest
     */
    'disable_split'?: boolean;
}
/**
 * 
 * @export
 * @interface SplitAfterPaymentRequestSplitInner
 */
export interface SplitAfterPaymentRequestSplitInner {
    /**
     * Specify the merchant vendor ID to split the payment.
     * @type {string}
     * @memberof SplitAfterPaymentRequestSplitInner
     */
    'vendor_id'?: string;
    /**
     * Specify the amount to be split to the vendor.
     * @type {number}
     * @memberof SplitAfterPaymentRequestSplitInner
     */
    'amount'?: number;
    /**
     * Specify the percentage of amount to be split.
     * @type {number}
     * @memberof SplitAfterPaymentRequestSplitInner
     */
    'percentage'?: number;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof SplitAfterPaymentRequestSplitInner
     */
    'tags'?: { [key: string]: string; };
}
/**
 * Split After Payment Response
 * @export
 * @interface SplitAfterPaymentResponse
 */
export interface SplitAfterPaymentResponse {
    /**
     * 
     * @type {string}
     * @memberof SplitAfterPaymentResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SplitAfterPaymentResponse
     */
    'message'?: string;
}
/**
 * Static Split Request
 * @export
 * @interface StaticSplitRequest
 */
export interface StaticSplitRequest {
    /**
     * Specify if the split is to be active or not. Possible values: true/false
     * @type {boolean}
     * @memberof StaticSplitRequest
     */
    'active': boolean;
    /**
     * For Subscription payments, the subscription reference ID is to be shared as the terminal ID. Incase for Payment Gateway terminal ID is non-mandatory. Mention as 0 if not applicable.
     * @type {string}
     * @memberof StaticSplitRequest
     */
    'terminal_id'?: string;
    /**
     * You can share additional information using the reference ID.
     * @type {number}
     * @memberof StaticSplitRequest
     */
    'terminal_reference_id'?: number;
    /**
     * Specify the product for which the split should be created. If you want split to be created for Payment Gateway pass value as \"PG\". If you want split to be created for Subscription, pass value as \"SBC\". Accepted values - \"STATIC_QR\", \"SBC\", \"PG\", \"EPOS\".
     * @type {string}
     * @memberof StaticSplitRequest
     */
    'product_type': string;
    /**
     * Provide the split scheme details.
     * @type {Array<StaticSplitRequestSchemeInner>}
     * @memberof StaticSplitRequest
     */
    'scheme': Array<StaticSplitRequestSchemeInner>;
}
/**
 * 
 * @export
 * @interface StaticSplitRequestSchemeInner
 */
export interface StaticSplitRequestSchemeInner {
    /**
     * Specify the merchant vendor ID to create the split scheme for the payment.
     * @type {string}
     * @memberof StaticSplitRequestSchemeInner
     */
    'merchantVendorId'?: string;
    /**
     * Specify the percentage of amount to be split.
     * @type {string}
     * @memberof StaticSplitRequestSchemeInner
     */
    'percentage'?: string;
}
/**
 * Static Split Response
 * @export
 * @interface StaticSplitResponse
 */
export interface StaticSplitResponse {
    /**
     * 
     * @type {boolean}
     * @memberof StaticSplitResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StaticSplitResponse
     */
    'terminal_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StaticSplitResponse
     */
    'terminal_reference_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StaticSplitResponse
     */
    'product_type'?: string;
    /**
     * 
     * @type {Array<StaticSplitResponseSchemeInner>}
     * @memberof StaticSplitResponse
     */
    'scheme'?: Array<StaticSplitResponseSchemeInner>;
    /**
     * 
     * @type {string}
     * @memberof StaticSplitResponse
     */
    'added_on'?: string;
}
/**
 * 
 * @export
 * @interface StaticSplitResponseSchemeInner
 */
export interface StaticSplitResponseSchemeInner {
    /**
     * 
     * @type {string}
     * @memberof StaticSplitResponseSchemeInner
     */
    'merchantVendorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof StaticSplitResponseSchemeInner
     */
    'percentage'?: string;
}
/**
 * Use this if you are creating an order for cashfree\'s softPOS
 * @export
 * @interface TerminalDetails
 */
export interface TerminalDetails {
    /**
     * date time at which terminal is added
     * @type {string}
     * @memberof TerminalDetails
     */
    'added_on'?: string;
    /**
     * cashfree terminal id
     * @type {string}
     * @memberof TerminalDetails
     */
    'cf_terminal_id'?: string;
    /**
     * last instant when this terminal was updated
     * @type {string}
     * @memberof TerminalDetails
     */
    'last_updated_on'?: string;
    /**
     * location of terminal
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_address'?: string;
    /**
     * terminal id for merchant reference
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_id': string;
    /**
     * name of terminal/agent/storefront
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_name'?: string;
    /**
     * note given by merchant while creating the terminal
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_note'?: string;
    /**
     * mobile num of the terminal/agent/storefront
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_phone_no': string;
    /**
     * status of terminal active/inactive
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_status'?: string;
    /**
     * To identify the type of terminal product in use, in this case it is SPOS.
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_type': string;
}
/**
 * Create terminal response object
 * @export
 * @interface TerminalEntity
 */
export interface TerminalEntity {
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'added_on'?: string;
    /**
     * 
     * @type {number}
     * @memberof TerminalEntity
     */
    'cf_terminal_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'last_updated_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'teminal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_note'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_phone_no'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_meta'?: string;
}
/**
 * terminal payment entity full object
 * @export
 * @interface TerminalPaymentEntity
 */
export interface TerminalPaymentEntity {
    /**
     * 
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'cf_payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'entity'?: string;
    /**
     * 
     * @type {ErrorDetailsInPaymentsEntity}
     * @memberof TerminalPaymentEntity
     */
    'error_details'?: ErrorDetailsInPaymentsEntity;
    /**
     * 
     * @type {boolean}
     * @memberof TerminalPaymentEntity
     */
    'is_captured'?: boolean;
    /**
     * Order amount can be different from payment amount if you collect service fee from the customer
     * @type {number}
     * @memberof TerminalPaymentEntity
     */
    'order_amount'?: number;
    /**
     * Type of payment group. One of [\'prepaid_card\', \'upi_ppi_offline\', \'cash\', \'upi_credit_card\', \'paypal\', \'net_banking\', \'cardless_emi\', \'credit_card\', \'bank_transfer\', \'pay_later\', \'debit_card_emi\', \'debit_card\', \'wallet\', \'upi_ppi\', \'upi\', \'credit_card_emi\']
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'payment_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'payment_currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof TerminalPaymentEntity
     */
    'payment_amount'?: number;
    /**
     * This is the time when the payment was initiated
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'payment_time'?: string;
    /**
     * This is the time when the payment reaches its terminal state
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'payment_completion_time'?: string;
    /**
     * The transaction status can be one of  [\"SUCCESS\", \"NOT_ATTEMPTED\", \"FAILED\", \"USER_DROPPED\", \"VOID\", \"CANCELLED\", \"PENDING\"]
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'payment_status'?: TerminalPaymentEntityPaymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'payment_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'bank_reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalPaymentEntity
     */
    'auth_id'?: string;
    /**
     * 
     * @type {AuthorizationInPaymentsEntity}
     * @memberof TerminalPaymentEntity
     */
    'authorization'?: AuthorizationInPaymentsEntity;
    /**
     * 
     * @type {CustomerDetails}
     * @memberof TerminalPaymentEntity
     */
    'customer_details'?: CustomerDetails;
    /**
     * 
     * @type {PaymentEntityPaymentMethod}
     * @memberof TerminalPaymentEntity
     */
    'payment_method'?: PaymentEntityPaymentMethod;
}

export const TerminalPaymentEntityPaymentStatusEnum = {
    SUCCESS: 'SUCCESS',
    NOT_ATTEMPTED: 'NOT_ATTEMPTED',
    FAILED: 'FAILED',
    USER_DROPPED: 'USER_DROPPED',
    VOID: 'VOID',
    CANCELLED: 'CANCELLED',
    PENDING: 'PENDING',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type TerminalPaymentEntityPaymentStatusEnum = typeof TerminalPaymentEntityPaymentStatusEnum[keyof typeof TerminalPaymentEntityPaymentStatusEnum];

/**
 * Create terminal response object
 * @export
 * @interface TerminalTransactionEntity
 */
export interface TerminalTransactionEntity {
    /**
     * 
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'cf_payment_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof TerminalTransactionEntity
     */
    'payment_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'payment_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'qrcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'timeout'?: string;
}
/**
 * Request to terminate an active order at Cashfree
 * @export
 * @interface TerminateOrderRequest
 */
export interface TerminateOrderRequest {
    /**
     * To terminate an order, pass order_status as \"TERMINATE\". Please note, order might not be terminated - confirm with the order_status in response. \"TERMINATION_REQUESTED\" states that the request is recieved and we are working on it. If the order terminates successfully, status will change to \"TERMINATED\". Incase there\'s any active transaction which moved to success - order might not get terminated.
     * @type {string}
     * @memberof TerminateOrderRequest
     */
    'order_status': string;
}
/**
 * 
 * @export
 * @interface TransferDetails
 */
export interface TransferDetails {
    /**
     * 
     * @type {string}
     * @memberof TransferDetails
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDetails
     */
    'transfer_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDetails
     */
    'transfer_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransferDetails
     */
    'transfer_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransferDetails
     */
    'remark'?: string;
    /**
     * 
     * @type {Array<TransferDetailsTagsInner>}
     * @memberof TransferDetails
     */
    'tags'?: Array<TransferDetailsTagsInner>;
}
/**
 * 
 * @export
 * @interface TransferDetailsTagsInner
 */
export interface TransferDetailsTagsInner {
    /**
     * 
     * @type {string}
     * @memberof TransferDetailsTagsInner
     */
    'product'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransferDetailsTagsInner
     */
    'size'?: number;
}
/**
 * object when you are using preauth in UPI in order pay
 * @export
 * @interface UPIAuthorizeDetails
 */
export interface UPIAuthorizeDetails {
    /**
     * Time by which this authorization should be approved by the customer.
     * @type {string}
     * @memberof UPIAuthorizeDetails
     */
    'approve_by'?: string;
    /**
     * This is the time when the UPI one time mandate will start
     * @type {string}
     * @memberof UPIAuthorizeDetails
     */
    'start_time'?: string;
    /**
     * This is the time when the UPI mandate will be over. If the mandate has not been executed by this time, the funds will be returned back to the customer after this time.
     * @type {string}
     * @memberof UPIAuthorizeDetails
     */
    'end_time'?: string;
}
/**
 * Complete payment method for UPI collect
 * @export
 * @interface UPIPaymentMethod
 */
export interface UPIPaymentMethod {
    /**
     * 
     * @type {Upi}
     * @memberof UPIPaymentMethod
     */
    'upi': Upi;
}
/**
 * Update terminal response
 * @export
 * @interface UpdateTerminalEntity
 */
export interface UpdateTerminalEntity {
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'added_on'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTerminalEntity
     */
    'cf_terminal_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'last_updated_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'teminal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_note'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_phone_no'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_meta'?: string;
}
/**
 * Request body to update terminal details.
 * @export
 * @interface UpdateTerminalRequest
 */
export interface UpdateTerminalRequest {
    /**
     * Mention the updated email ID of the terminal.
     * @type {string}
     * @memberof UpdateTerminalRequest
     */
    'terminal_email'?: string;
    /**
     * Terminal phone number to be updated.
     * @type {string}
     * @memberof UpdateTerminalRequest
     */
    'terminal_phone_no'?: string;
    /**
     * 
     * @type {UpdateTerminalRequestTerminalMeta}
     * @memberof UpdateTerminalRequest
     */
    'terminal_meta'?: UpdateTerminalRequestTerminalMeta;
    /**
     * Mention the terminal type to be updated. Possible values - AGENT, STOREFRONT.
     * @type {string}
     * @memberof UpdateTerminalRequest
     */
    'terminal_type': string;
}
/**
 * Terminal metadata.
 * @export
 * @interface UpdateTerminalRequestTerminalMeta
 */
export interface UpdateTerminalRequestTerminalMeta {
    /**
     * Name of the operator for the storefront.
     * @type {string}
     * @memberof UpdateTerminalRequestTerminalMeta
     */
    'terminal_operator'?: string;
}
/**
 * Request body to update terminal status.
 * @export
 * @interface UpdateTerminalStatusRequest
 */
export interface UpdateTerminalStatusRequest {
    /**
     * Status of the terminal to be updated. possible values - ACTIVE, INACTIVE.
     * @type {string}
     * @memberof UpdateTerminalStatusRequest
     */
    'terminal_status': string;
}
/**
 * Update Vendor Request
 * @export
 * @interface UpdateVendorRequest
 */
export interface UpdateVendorRequest {
    /**
     * Specify the status of vendor that should be updated. Possible values: ACTIVE,BLOCKED, DELETED
     * @type {string}
     * @memberof UpdateVendorRequest
     */
    'status': string;
    /**
     * Specify the name of the vendor to be updated. Name should not have any special character except . / - &
     * @type {string}
     * @memberof UpdateVendorRequest
     */
    'name': string;
    /**
     * Specify the vendor email ID that should be updated. String in email ID format (Ex:johndoe_1@cashfree.com) should contain @ and dot (.)
     * @type {string}
     * @memberof UpdateVendorRequest
     */
    'email': string;
    /**
     * Specify the beneficiaries phone number to be updated. Phone number registered in India (only digits, 8 - 12 characters after excluding +91).
     * @type {string}
     * @memberof UpdateVendorRequest
     */
    'phone': string;
    /**
     * Specify if the vendor bank account details should be verified. Possible values: true or false
     * @type {boolean}
     * @memberof UpdateVendorRequest
     */
    'verify_account'?: boolean;
    /**
     * Update if the vendor will have dashboard access or not. Possible values are: true or false
     * @type {boolean}
     * @memberof UpdateVendorRequest
     */
    'dashboard_access'?: boolean;
    /**
     * Specify the settlement cycle to be updated. View the settlement cycle details from the \"Settlement Cycles Supported\" table. If no schedule option is configured, the settlement cycle ID \"1\" will be in effect. Select \"8\" or \"9\" if you want to schedule instant vendor settlements.
     * @type {number}
     * @memberof UpdateVendorRequest
     */
    'schedule_option': number;
    /**
     * Specify the vendor bank account details to be updated.
     * @type {Array<BankDetails>}
     * @memberof UpdateVendorRequest
     */
    'bank'?: Array<BankDetails>;
    /**
     * Updated beneficiary upi vpa. Alphanumeric, dot (.), hyphen (-), at sign (@), and underscore allowed (100 character limit). Note: underscore and dot (.) gets accepted before and after @, but hyphen (-) is only accepted before @ sign.
     * @type {Array<UpiDetails>}
     * @memberof UpdateVendorRequest
     */
    'upi'?: Array<UpiDetails>;
    /**
     * Specify the kyc details that should be updated.
     * @type {Array<KycDetails>}
     * @memberof UpdateVendorRequest
     */
    'kyc_details': Array<KycDetails>;
}
/**
 * Update Vendor Response
 * @export
 * @interface UpdateVendorResponse
 */
export interface UpdateVendorResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'status'?: string;
    /**
     * 
     * @type {Array<BankDetails>}
     * @memberof UpdateVendorResponse
     */
    'bank'?: Array<BankDetails>;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'upi'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'added_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'updated_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'vendor_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'account_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'business_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateVendorResponse
     */
    'phone'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {Array<ScheduleOption>}
     * @memberof UpdateVendorResponse
     */
    'schedule_option'?: Array<ScheduleOption>;
    /**
     * 
     * @type {Array<KycDetails>}
     * @memberof UpdateVendorResponse
     */
    'kyc_details'?: Array<KycDetails>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateVendorResponse
     */
    'dashboard_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateVendorResponse
     */
    'bank_details'?: string;
    /**
     * 
     * @type {Array<VendorEntityRelatedDocsInner>}
     * @memberof UpdateVendorResponse
     */
    'related_docs'?: Array<VendorEntityRelatedDocsInner>;
}
/**
 * UPI collect payment method object
 * @export
 * @interface Upi
 */
export interface Upi {
    /**
     * Specify the channel through which the payment must be processed. Can be one of [\"link\", \"collect\", \"qrcode\"]
     * @type {string}
     * @memberof Upi
     */
    'channel': UpiChannelEnum;
    /**
     * Customer UPI VPA to process payment.  ### Important This is a required parameter for channel = `collect` 
     * @type {string}
     * @memberof Upi
     */
    'upi_id'?: string;
    /**
     * use this if you want cashfree to show a loader. Sample response below. It is only supported for collect `action:collect` will be returned with `data.url` having the link for redirection 
     * @type {boolean}
     * @memberof Upi
     */
    'upi_redirect_url'?: boolean;
    /**
     * The UPI request will be valid for this expiry minutes. This parameter is only applicable for a UPI collect payment. The default value is 5 minutes. You should keep the minimum as 5 minutes, and maximum as 15 minutes
     * @type {number}
     * @memberof Upi
     */
    'upi_expiry_minutes'?: number;
    /**
     * For one time mandate on UPI. Set this as authorize_only = true. Please note that you can only use the \"collect\" channel if you are sending a one time mandate request
     * @type {boolean}
     * @memberof Upi
     */
    'authorize_only'?: boolean;
    /**
     * 
     * @type {UPIAuthorizeDetails}
     * @memberof Upi
     */
    'authorization'?: UPIAuthorizeDetails;
}

export const UpiChannelEnum = {
    LINK: 'link',
    COLLECT: 'collect',
    QRCODE: 'qrcode',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;

export type UpiChannelEnum = typeof UpiChannelEnum[keyof typeof UpiChannelEnum];

/**
 * 
 * @export
 * @interface UpiDetails
 */
export interface UpiDetails {
    /**
     * 
     * @type {string}
     * @memberof UpiDetails
     */
    'vpa'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpiDetails
     */
    'account_holder'?: string;
}
/**
 * Request body to upload terminal documents.
 * @export
 * @interface UploadTerminalDocs
 */
export interface UploadTerminalDocs {
    /**
     * Mention the document type you are uploading. Possible values - ADDRESSPROOF, PHOTOGRAPH.
     * @type {string}
     * @memberof UploadTerminalDocs
     */
    'doc_type': string;
    /**
     * Enter the display name of the uploaded file.
     * @type {string}
     * @memberof UploadTerminalDocs
     */
    'doc_value': string;
    /**
     * Select the document that should be uploaded or provide the path of that file. You cannot upload a file that is more than 2MB in size.
     * @type {string}
     * @memberof UploadTerminalDocs
     */
    'file': string;
}
/**
 * Upload the terminal documents.
 * @export
 * @interface UploadTerminalDocsEntity
 */
export interface UploadTerminalDocsEntity {
    /**
     * 
     * @type {number}
     * @memberof UploadTerminalDocsEntity
     */
    'cf_terminal_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadTerminalDocsEntity
     */
    'doc_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadTerminalDocsEntity
     */
    'doc_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadTerminalDocsEntity
     */
    'status'?: string;
}
/**
 * Upload Vendor Document
 * @export
 * @interface UploadVendorDocumentsResponse
 */
export interface UploadVendorDocumentsResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadVendorDocumentsResponse
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadVendorDocumentsResponse
     */
    'doc_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadVendorDocumentsResponse
     */
    'doc_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadVendorDocumentsResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadVendorDocumentsResponse
     */
    'remarks'?: string;
}
/**
 * Vendor Balance entity object
 * @export
 * @interface VendorBalance
 */
export interface VendorBalance {
    /**
     * 
     * @type {number}
     * @memberof VendorBalance
     */
    'merchant_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof VendorBalance
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VendorBalance
     */
    'merchant_unsettled'?: number;
    /**
     * 
     * @type {number}
     * @memberof VendorBalance
     */
    'vendor_unsettled'?: number;
}
/**
 * Vendor Balance Transfer Charges entity object
 * @export
 * @interface VendorBalanceTransferCharges
 */
export interface VendorBalanceTransferCharges {
    /**
     * 
     * @type {number}
     * @memberof VendorBalanceTransferCharges
     */
    'service_charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof VendorBalanceTransferCharges
     */
    'service_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof VendorBalanceTransferCharges
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof VendorBalanceTransferCharges
     */
    'billed_to'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VendorBalanceTransferCharges
     */
    'is_postpaid'?: boolean;
}
/**
 * Download Vendor Document
 * @export
 * @interface VendorDocumentDownloadResponse
 */
export interface VendorDocumentDownloadResponse {
    /**
     * 
     * @type {string}
     * @memberof VendorDocumentDownloadResponse
     */
    'download_url'?: string;
}
/**
 * Get Vendor Documents
 * @export
 * @interface VendorDocumentsResponse
 */
export interface VendorDocumentsResponse {
    /**
     * 
     * @type {Array<VendorEntityRelatedDocsInner>}
     * @memberof VendorDocumentsResponse
     */
    'documents'?: Array<VendorEntityRelatedDocsInner>;
}
/**
 * Vendor entity object
 * @export
 * @interface VendorEntity
 */
export interface VendorEntity {
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'added_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'updated_on'?: string;
    /**
     * 
     * @type {Array<BankDetails>}
     * @memberof VendorEntity
     */
    'bank'?: Array<BankDetails>;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'upi'?: string;
    /**
     * 
     * @type {Array<ScheduleOption>}
     * @memberof VendorEntity
     */
    'schedule_option'?: Array<ScheduleOption>;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'vendor_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'account_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntity
     */
    'business_type'?: string;
    /**
     * 
     * @type {Array<VendorEntityRelatedDocsInner>}
     * @memberof VendorEntity
     */
    'related_docs'?: Array<VendorEntityRelatedDocsInner>;
}
/**
 * 
 * @export
 * @interface VendorEntityRelatedDocsInner
 */
export interface VendorEntityRelatedDocsInner {
    /**
     * 
     * @type {string}
     * @memberof VendorEntityRelatedDocsInner
     */
    'vendor_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntityRelatedDocsInner
     */
    'doc_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntityRelatedDocsInner
     */
    'doc_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntityRelatedDocsInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorEntityRelatedDocsInner
     */
    'remarks'?: string;
}
/**
 * Use to split order when cashfree\'s Easy Split is enabled for your account.
 * @export
 * @interface VendorSplit
 */
export interface VendorSplit {
    /**
     * Vendor id created in Cashfree system
     * @type {string}
     * @memberof VendorSplit
     */
    'vendor_id': string;
    /**
     * Amount which will be associated with this vendor
     * @type {number}
     * @memberof VendorSplit
     */
    'amount'?: number;
    /**
     * Percentage of order amount which shall get added to vendor account
     * @type {number}
     * @memberof VendorSplit
     */
    'percentage'?: number;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: object; }}
     * @memberof VendorSplit
     */
    'tags'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface WalletOffer
 */
export interface WalletOffer {
    /**
     * 
     * @type {string}
     * @memberof WalletOffer
     */
    'provider'?: string;
}

/**
 * CustomersApi - axios parameter creator
 * @export
 */
const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Customer at Cashfree
         * @summary Create Customer at Cashfree
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateCustomerRequest} CreateCustomerRequest Request to create a new customer at Cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGCreateCustomer: async (x_api_version: string, CreateCustomerRequest: CreateCustomerRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCreateCustomer', 'x_api_version', x_api_version)
            // verify required parameter 'CreateCustomerRequest' is not null or undefined
            assertParamExists('pGCreateCustomer', 'CreateCustomerRequest', CreateCustomerRequest)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create Customer at Cashfree
         * @summary Create Customer at Cashfree
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateCustomerRequest} CreateCustomerRequest Request to create a new customer at Cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCreateCustomer(x_api_version: string, CreateCustomerRequest: CreateCustomerRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCreateCustomer(x_api_version, CreateCustomerRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */



/**
 * EasySplitApi - axios parameter creator
 * @export
 */
const EasySplitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Create On Demand Transfer API will create a new on-demand request either from to the merchant or from to the vendor.
         * @summary Create On Demand Transfer
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {AdjustVendorBalanceRequest} [AdjustVendorBalanceRequest] Adjust Vendor Balance Request Body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGESCreateOnDemandTransfer: async (x_api_version: string, vendor_id: string,  x_request_id?: string, x_idempotency_key?: string, AdjustVendorBalanceRequest?: AdjustVendorBalanceRequest,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESCreateOnDemandTransfer', 'x_api_version', x_api_version)
            // verify required parameter 'vendor_id' is not null or undefined
            assertParamExists('pGESCreateOnDemandTransfer', 'vendor_id', vendor_id)
            const localVarPath = `/easy-split/vendors/{vendor_id}/transfer`
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendor_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(AdjustVendorBalanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a new vendor to your EasySplit account along with the KYC details. Provide KYC details such as account_type, business_type, gst, cin, pan, passport number and so on.
         * @summary Create vendor
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {CreateVendorRequest} [CreateVendorRequest] Create Vendor Request Body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * CreateVendorRequest?: CreateVendorRequest, 
         */
        pGESCreateVendors: async (x_api_version: string,  x_request_id?: string, x_idempotency_key?: string, CreateVendorRequest?: CreateVendorRequest,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESCreateVendors', 'x_api_version', x_api_version)
            const localVarPath = `/easy-split/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateVendorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to download the uploaded KYC documents of that particular vendor. Provide the document type. Click the link from the sample request to download the KYC document.
         * @summary Download Vendor Documents
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} doc_type Mention the document type that has to be downloaded. Only an uploaded document can be downloaded.
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGESDownloadVendorsDocs: async (x_api_version: string, doc_type: string, vendor_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESDownloadVendorsDocs', 'x_api_version', x_api_version)
            // verify required parameter 'doc_type' is not null or undefined
            assertParamExists('pGESDownloadVendorsDocs', 'doc_type', doc_type)
            // verify required parameter 'vendor_id' is not null or undefined
            assertParamExists('pGESDownloadVendorsDocs', 'vendor_id', vendor_id)
            const localVarPath = `/easy-split/vendor-docs/{vendor_id}/download/{doc_type}`
                .replace(`{${"doc_type"}}`, encodeURIComponent(String(doc_type)))
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendor_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get the details of a specific vendor associated with your Easy Split account.
         * @summary Get Vendor All Details
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGESFetchVendors: async (x_api_version: string, vendor_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESFetchVendors', 'x_api_version', x_api_version)
            // verify required parameter 'vendor_id' is not null or undefined
            assertParamExists('pGESFetchVendors', 'vendor_id', vendor_id)
            const localVarPath = `/easy-split/vendors/{vendor_id}`
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendor_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API fetches the available amount with the merchant, vendor, and the unsettled amount for the merchant as well as the vendor.
         * @summary Get On Demand Balance
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGESGetVendorBalance: async (x_api_version: string, vendor_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESGetVendorBalance', 'x_api_version', x_api_version)
            // verify required parameter 'vendor_id' is not null or undefined
            assertParamExists('pGESGetVendorBalance', 'vendor_id', vendor_id)
            const localVarPath = `/easy-split/vendors/{vendor_id}/balances`
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendor_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API returns the applicable service charge and service tax for a vendor balance transfer, based on the provided amount and rate type.
         * @summary Get Vendor Balance Transfer Charges
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {number} amount Specify the amount for which you want to view the service charges and service taxes in the response.
         * @param {string} rate_type Mention the type of rate for which you want to check the charges. Possible value: VENDOR_ON_DEMAND
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGESGetVendorBalanceTransferCharges: async (x_api_version: string, amount: number, rate_type: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESGetVendorBalanceTransferCharges', 'x_api_version', x_api_version)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('pGESGetVendorBalanceTransferCharges', 'amount', amount)
            // verify required parameter 'rate_type' is not null or undefined
            assertParamExists('pGESGetVendorBalanceTransferCharges', 'rate_type', rate_type)
            const localVarPath = `/easy-split/amount/{amount}/charges`
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")

            if (rate_type !== undefined) {
                localVarQueryParameter['rate_type'] = rate_type;
            }


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch the details of all the KYC details of a particular vendor.
         * @summary Get Vendor All Documents Status
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGESGetVendorsDocs: async (x_api_version: string, vendor_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESGetVendorsDocs', 'x_api_version', x_api_version)
            // verify required parameter 'vendor_id' is not null or undefined
            assertParamExists('pGESGetVendorsDocs', 'vendor_id', vendor_id)
            const localVarPath = `/easy-split/vendor-docs/{vendor_id}`
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendor_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get all the split details, settled and unsettled transactions details of each vendor who were part of a particular order by providing order Id or start date and end date.
         * @summary Get Split and Settlement Details by OrderID v2.0
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {ESOrderReconRequest} [ESOrderReconRequest] Get Split and Settlement Details by OrderID v2.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * ESOrderReconRequest?: ESOrderReconRequest, 
         */
        pGESOrderRecon: async (x_api_version: string,  x_request_id?: string, x_idempotency_key?: string, ESOrderReconRequest?: ESOrderReconRequest,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESOrderRecon', 'x_api_version', x_api_version)
            const localVarPath = `/split/order/vendor/recon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ESOrderReconRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to edit the existing vendor details added to your EasySplit account. You can edit vendor details such as name, email, phone number, upi details, and any of the KYC details.
         * @summary Update vendor Details
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {UpdateVendorRequest} [UpdateVendorRequest] Create Vendor Request Body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGESUpdateVendors: async (x_api_version: string, vendor_id: string,  x_request_id?: string, x_idempotency_key?: string, UpdateVendorRequest?: UpdateVendorRequest,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESUpdateVendors', 'x_api_version', x_api_version)
            // verify required parameter 'vendor_id' is not null or undefined
            assertParamExists('pGESUpdateVendors', 'vendor_id', vendor_id)
            const localVarPath = `/easy-split/vendors/{vendor_id}`
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendor_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateVendorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to upload KYC documents of a specific vendor.
         * @summary Upload Vendor Docs
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [doc_type] Mention the type of the document you are uploading. Possible values: UIDAI_FRONT, UIDAI_BACK, UIDAI_NUMBER, DL, DL_NUMBER, PASSPORT_FRONT, PASSPORT_BACK, PASSPORT_NUMBER, VOTER_ID, VOTER_ID_NUMBER, PAN, PAN_NUMBER, GST, GSTIN_NUMBER, CIN, CIN_NUMBER, NBFC_CERTIFICATE. If the doc type ends with a number you should add the doc value else upload the doc file.
         * @param {string} [doc_value] Enter the display name of the uploaded file.
         * @param {File} [file] Select the document that should be uploaded or provide the path of that file. You cannot upload a file that is more than 2MB in size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGESUploadVendorsDocs: async (x_api_version: string, vendor_id: string,  x_request_id?: string, x_idempotency_key?: string, doc_type?: string, doc_value?: string, file?: File,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGESUploadVendorsDocs', 'x_api_version', x_api_version)
            // verify required parameter 'vendor_id' is not null or undefined
            assertParamExists('pGESUploadVendorsDocs', 'vendor_id', vendor_id)
            const localVarPath = `/easy-split/vendor-docs/{vendor_id}`
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendor_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


            if (doc_type !== undefined) { 
                localVarFormParams.append('doc_type', doc_type as any);
            }
    
            if (doc_value !== undefined) { 
                localVarFormParams.append('doc_value', doc_value as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Split After Payment API splits the payments to vendors after successful payment from the customers.
         * @summary Split After Payment
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {SplitAfterPaymentRequest} [SplitAfterPaymentRequest] Request Body to Create Split for an order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGOrderSplitAfterPayment: async (x_api_version: string, order_id: string,  x_request_id?: string, x_idempotency_key?: string, SplitAfterPaymentRequest?: SplitAfterPaymentRequest,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderSplitAfterPayment', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGOrderSplitAfterPayment', 'order_id', order_id)
            const localVarPath = `/easy-split/orders/{order_id}/split`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(SplitAfterPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API will create a static split scheme wherein you can define the split type and the vendor-wise split percentage.
         * @summary Create Static Split Configuration
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {StaticSplitRequest} [StaticSplitRequest] Static Split
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * StaticSplitRequest?: StaticSplitRequest, 
         */
        pGOrderStaticSplit: async (x_api_version: string,  x_request_id?: string, x_idempotency_key?: string, StaticSplitRequest?: StaticSplitRequest,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderStaticSplit', 'x_api_version', x_api_version)
            const localVarPath = `/easy-split/static-split`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(StaticSplitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EasySplitApi - functional programming interface
 * @export
 */
const EasySplitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EasySplitApiAxiosParamCreator(configuration)
    return {
        /**
         * The Create On Demand Transfer API will create a new on-demand request either from to the merchant or from to the vendor.
         * @summary Create On Demand Transfer
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {AdjustVendorBalanceRequest} [AdjustVendorBalanceRequest] Adjust Vendor Balance Request Body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESCreateOnDemandTransfer(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, AdjustVendorBalanceRequest?: AdjustVendorBalanceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdjustVendorBalanceResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESCreateOnDemandTransfer(x_api_version, vendor_id, x_request_id, x_idempotency_key, AdjustVendorBalanceRequest, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to create a new vendor to your EasySplit account along with the KYC details. Provide KYC details such as account_type, business_type, gst, cin, pan, passport number and so on.
         * @summary Create vendor
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {CreateVendorRequest} [CreateVendorRequest] Create Vendor Request Body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESCreateVendors(x_api_version: string, x_request_id?: string, x_idempotency_key?: string, CreateVendorRequest?: CreateVendorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVendorResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESCreateVendors(x_api_version, x_request_id, x_idempotency_key, CreateVendorRequest, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to download the uploaded KYC documents of that particular vendor. Provide the document type. Click the link from the sample request to download the KYC document.
         * @summary Download Vendor Documents
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} doc_type Mention the document type that has to be downloaded. Only an uploaded document can be downloaded.
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESDownloadVendorsDocs(x_api_version: string, doc_type: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorDocumentDownloadResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESDownloadVendorsDocs(x_api_version, doc_type, vendor_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to get the details of a specific vendor associated with your Easy Split account.
         * @summary Get Vendor All Details
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESFetchVendors(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESFetchVendors(x_api_version, vendor_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * This API fetches the available amount with the merchant, vendor, and the unsettled amount for the merchant as well as the vendor.
         * @summary Get On Demand Balance
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESGetVendorBalance(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorBalance>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESGetVendorBalance(x_api_version, vendor_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * This API returns the applicable service charge and service tax for a vendor balance transfer, based on the provided amount and rate type.
         * @summary Get Vendor Balance Transfer Charges
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {number} amount Specify the amount for which you want to view the service charges and service taxes in the response.
         * @param {string} rate_type Mention the type of rate for which you want to check the charges. Possible value: VENDOR_ON_DEMAND
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESGetVendorBalanceTransferCharges(x_api_version: string, amount: number, rate_type: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorBalanceTransferCharges>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESGetVendorBalanceTransferCharges(x_api_version, amount, rate_type, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to fetch the details of all the KYC details of a particular vendor.
         * @summary Get Vendor All Documents Status
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESGetVendorsDocs(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorDocumentsResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESGetVendorsDocs(x_api_version, vendor_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to get all the split details, settled and unsettled transactions details of each vendor who were part of a particular order by providing order Id or start date and end date.
         * @summary Get Split and Settlement Details by OrderID v2.0
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {ESOrderReconRequest} [ESOrderReconRequest] Get Split and Settlement Details by OrderID v2.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESOrderRecon(x_api_version: string, x_request_id?: string, x_idempotency_key?: string, ESOrderReconRequest?: ESOrderReconRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ESOrderReconResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESOrderRecon(x_api_version, x_request_id, x_idempotency_key, ESOrderReconRequest, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to edit the existing vendor details added to your EasySplit account. You can edit vendor details such as name, email, phone number, upi details, and any of the KYC details.
         * @summary Update vendor Details
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {UpdateVendorRequest} [UpdateVendorRequest] Create Vendor Request Body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESUpdateVendors(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, UpdateVendorRequest?: UpdateVendorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateVendorResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESUpdateVendors(x_api_version, vendor_id, x_request_id, x_idempotency_key, UpdateVendorRequest, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to upload KYC documents of a specific vendor.
         * @summary Upload Vendor Docs
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} vendor_id The id which uniquely identifies your vendor.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [doc_type] Mention the type of the document you are uploading. Possible values: UIDAI_FRONT, UIDAI_BACK, UIDAI_NUMBER, DL, DL_NUMBER, PASSPORT_FRONT, PASSPORT_BACK, PASSPORT_NUMBER, VOTER_ID, VOTER_ID_NUMBER, PAN, PAN_NUMBER, GST, GSTIN_NUMBER, CIN, CIN_NUMBER, NBFC_CERTIFICATE. If the doc type ends with a number you should add the doc value else upload the doc file.
         * @param {string} [doc_value] Enter the display name of the uploaded file.
         * @param {File} [file] Select the document that should be uploaded or provide the path of that file. You cannot upload a file that is more than 2MB in size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGESUploadVendorsDocs(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, doc_type?: string, doc_value?: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadVendorDocumentsResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGESUploadVendorsDocs(x_api_version, vendor_id, x_request_id, x_idempotency_key, doc_type, doc_value, file, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Split After Payment API splits the payments to vendors after successful payment from the customers.
         * @summary Split After Payment
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {SplitAfterPaymentRequest} [SplitAfterPaymentRequest] Request Body to Create Split for an order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderSplitAfterPayment(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, SplitAfterPaymentRequest?: SplitAfterPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitAfterPaymentResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderSplitAfterPayment(x_api_version, order_id, x_request_id, x_idempotency_key, SplitAfterPaymentRequest, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * This API will create a static split scheme wherein you can define the split type and the vendor-wise split percentage.
         * @summary Create Static Split Configuration
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {StaticSplitRequest} [StaticSplitRequest] Static Split
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderStaticSplit(x_api_version: string, x_request_id?: string, x_idempotency_key?: string, StaticSplitRequest?: StaticSplitRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaticSplitResponse>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderStaticSplit(x_api_version, x_request_id, x_idempotency_key, StaticSplitRequest, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * EasySplitApi - object-oriented interface
 * @export
 * @class EasySplitApi
 * @extends {BaseAPI}
 */



/**
 * EligibilityApi - axios parameter creator
 * @export
 */
const EligibilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to get eligible Cardless EMI Payment Methods available for a customer on an order basis their phone number.
         * @summary Get Eligible Cardless EMI Payment Methods for a customer on an order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchCardlessEMIRequest} EligibilityFetchCardlessEMIRequest Request Body to get eligible cardless emi options for a customer and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGEligibilityFetchCardlessEMI: async (x_api_version: string, EligibilityFetchCardlessEMIRequest: EligibilityFetchCardlessEMIRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGEligibilityFetchCardlessEMI', 'x_api_version', x_api_version)
            // verify required parameter 'EligibilityFetchCardlessEMIRequest' is not null or undefined
            assertParamExists('pGEligibilityFetchCardlessEMI', 'EligibilityFetchCardlessEMIRequest', EligibilityFetchCardlessEMIRequest)
            const localVarPath = `/eligibility/cardlessemi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(EligibilityFetchCardlessEMIRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get eligible offers for an order_id or order amount.
         * @summary Get Eligible Offers for an Order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchOffersRequest} EligibilityFetchOffersRequest Request Body to get eligible offers for a customer and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGEligibilityFetchOffers: async (x_api_version: string, EligibilityFetchOffersRequest: EligibilityFetchOffersRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGEligibilityFetchOffers', 'x_api_version', x_api_version)
            // verify required parameter 'EligibilityFetchOffersRequest' is not null or undefined
            assertParamExists('pGEligibilityFetchOffers', 'EligibilityFetchOffersRequest', EligibilityFetchOffersRequest)
            const localVarPath = `/eligibility/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(EligibilityFetchOffersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get eligible Paylater Payment Methods for a customer on an order.
         * @summary Get Eligible Paylater for a customer on an order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchPaylaterRequest} EligibilityFetchPaylaterRequest Request Body to get eligible paylater options for a customer and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGEligibilityFetchPaylater: async (x_api_version: string, EligibilityFetchPaylaterRequest: EligibilityFetchPaylaterRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGEligibilityFetchPaylater', 'x_api_version', x_api_version)
            // verify required parameter 'EligibilityFetchPaylaterRequest' is not null or undefined
            assertParamExists('pGEligibilityFetchPaylater', 'EligibilityFetchPaylaterRequest', EligibilityFetchPaylaterRequest)
            const localVarPath = `/eligibility/paylater`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(EligibilityFetchPaylaterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get eligible Payment Methods
         * @summary Get eligible Payment Methods
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchPaymentMethodsRequest} EligibilityFetchPaymentMethodsRequest Request Body to get eligible payment methods for an account and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGEligibilityFetchPaymentMethods: async (x_api_version: string, EligibilityFetchPaymentMethodsRequest: EligibilityFetchPaymentMethodsRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGEligibilityFetchPaymentMethods', 'x_api_version', x_api_version)
            // verify required parameter 'EligibilityFetchPaymentMethodsRequest' is not null or undefined
            assertParamExists('pGEligibilityFetchPaymentMethods', 'EligibilityFetchPaymentMethodsRequest', EligibilityFetchPaymentMethodsRequest)
            const localVarPath = `/eligibility/payment_methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(EligibilityFetchPaymentMethodsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EligibilityApi - functional programming interface
 * @export
 */
const EligibilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EligibilityApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to get eligible Cardless EMI Payment Methods available for a customer on an order basis their phone number.
         * @summary Get Eligible Cardless EMI Payment Methods for a customer on an order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchCardlessEMIRequest} EligibilityFetchCardlessEMIRequest Request Body to get eligible cardless emi options for a customer and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGEligibilityFetchCardlessEMI(x_api_version: string, EligibilityFetchCardlessEMIRequest: EligibilityFetchCardlessEMIRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EligibilityCardlessEMIEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGEligibilityFetchCardlessEMI(x_api_version, EligibilityFetchCardlessEMIRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to get eligible offers for an order_id or order amount.
         * @summary Get Eligible Offers for an Order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchOffersRequest} EligibilityFetchOffersRequest Request Body to get eligible offers for a customer and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGEligibilityFetchOffers(x_api_version: string, EligibilityFetchOffersRequest: EligibilityFetchOffersRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EligibilityOfferEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGEligibilityFetchOffers(x_api_version, EligibilityFetchOffersRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to get eligible Paylater Payment Methods for a customer on an order.
         * @summary Get Eligible Paylater for a customer on an order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchPaylaterRequest} EligibilityFetchPaylaterRequest Request Body to get eligible paylater options for a customer and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGEligibilityFetchPaylater(x_api_version: string, EligibilityFetchPaylaterRequest: EligibilityFetchPaylaterRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EligibilityPaylaterEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGEligibilityFetchPaylater(x_api_version, EligibilityFetchPaylaterRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to get eligible Payment Methods
         * @summary Get eligible Payment Methods
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {EligibilityFetchPaymentMethodsRequest} EligibilityFetchPaymentMethodsRequest Request Body to get eligible payment methods for an account and order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGEligibilityFetchPaymentMethods(x_api_version: string, EligibilityFetchPaymentMethodsRequest: EligibilityFetchPaymentMethodsRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EligibilityPaymentMethodsEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGEligibilityFetchPaymentMethods(x_api_version, EligibilityFetchPaymentMethodsRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * EligibilityApi - object-oriented interface
 * @export
 * @class EligibilityApi
 * @extends {BaseAPI}
 */



/**
 * OffersApi - axios parameter creator
 * @export
 */
const OffersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to create offers with Cashfree from your backend
         * @summary Create Offer
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateOfferRequest} CreateOfferRequest Request body to create an offer at Cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGCreateOffer: async (x_api_version: string, CreateOfferRequest: CreateOfferRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCreateOffer', 'x_api_version', x_api_version)
            // verify required parameter 'CreateOfferRequest' is not null or undefined
            assertParamExists('pGCreateOffer', 'CreateOfferRequest', CreateOfferRequest)
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateOfferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get offer by offer_id
         * @summary Get Offer by ID
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} offer_id The offer ID for which you want to view the offer details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGFetchOffer: async (x_api_version: string, offer_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGFetchOffer', 'x_api_version', x_api_version)
            // verify required parameter 'offer_id' is not null or undefined
            assertParamExists('pGFetchOffer', 'offer_id', offer_id)
            const localVarPath = `/offers/{offer_id}`
                .replace(`{${"offer_id"}}`, encodeURIComponent(String(offer_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OffersApi - functional programming interface
 * @export
 */
const OffersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OffersApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to create offers with Cashfree from your backend
         * @summary Create Offer
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateOfferRequest} CreateOfferRequest Request body to create an offer at Cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCreateOffer(x_api_version: string, CreateOfferRequest: CreateOfferRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCreateOffer(x_api_version, CreateOfferRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to get offer by offer_id
         * @summary Get Offer by ID
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} offer_id The offer ID for which you want to view the offer details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGFetchOffer(x_api_version: string, offer_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGFetchOffer(x_api_version, offer_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * OffersApi - object-oriented interface
 * @export
 * @class OffersApi
 * @extends {BaseAPI}
 */



/**
 * OrdersApi - axios parameter creator
 * @export
 */
const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ### Order An order is an entity which has a amount and currency associated with it. It is something for which you want to collect payment for. Use this API to create orders with Cashfree from your backend to get a `payment_sessions_id`.  You can use the `payment_sessions_id` to create a transaction for the order. 
         * @summary Create Order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateOrderRequest} CreateOrderRequest Request body to create an order at cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGCreateOrder: async (x_api_version: string, CreateOrderRequest: CreateOrderRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCreateOrder', 'x_api_version', x_api_version)
            // verify required parameter 'CreateOrderRequest' is not null or undefined
            assertParamExists('pGCreateOrder', 'CreateOrderRequest', CreateOrderRequest)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch the order that was created at Cashfree\'s using the `order_id`.  ## When to use this API - To check the status of your order - Once the order is PAID - Once your customer returns to `return_url` 
         * @summary Get Order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGFetchOrder: async (x_api_version: string, order_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGFetchOrder', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGFetchOrder', 'order_id', order_id)
            const localVarPath = `/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to terminate the order that was created at Cashfree\'s using the `order_id`.
         * @summary Terminate Order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {TerminateOrderRequest} TerminateOrderRequest Request body to terminate an order at cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGTerminateOrder: async (x_api_version: string, order_id: string, TerminateOrderRequest: TerminateOrderRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGTerminateOrder', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGTerminateOrder', 'order_id', order_id)
            // verify required parameter 'TerminateOrderRequest' is not null or undefined
            assertParamExists('pGTerminateOrder', 'TerminateOrderRequest', TerminateOrderRequest)
            const localVarPath = `/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(TerminateOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * ### Order An order is an entity which has a amount and currency associated with it. It is something for which you want to collect payment for. Use this API to create orders with Cashfree from your backend to get a `payment_sessions_id`.  You can use the `payment_sessions_id` to create a transaction for the order. 
         * @summary Create Order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateOrderRequest} CreateOrderRequest Request body to create an order at cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCreateOrder(x_api_version: string, CreateOrderRequest: CreateOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCreateOrder(x_api_version, CreateOrderRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to fetch the order that was created at Cashfree\'s using the `order_id`.  ## When to use this API - To check the status of your order - Once the order is PAID - Once your customer returns to `return_url` 
         * @summary Get Order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGFetchOrder(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGFetchOrder(x_api_version, order_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to terminate the order that was created at Cashfree\'s using the `order_id`.
         * @summary Terminate Order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {TerminateOrderRequest} TerminateOrderRequest Request body to terminate an order at cashfree
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGTerminateOrder(x_api_version: string, order_id: string, TerminateOrderRequest: TerminateOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGTerminateOrder(x_api_version, order_id, TerminateOrderRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */



/**
 * PGReconciliationApi - axios parameter creator
 * @export
 */
const PGReconciliationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Use this API to get the payment gateway reconciliation details with date range. - It will have events for your payment account 
         * @summary PG Reconciliation
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {FetchReconRequest} FetchReconRequest Request Body for the reconciliation
         * @param {string} [Content_Type] application/json
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [Accept] application/json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGFetchRecon: async (x_api_version: string, FetchReconRequest: FetchReconRequest,  Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGFetchRecon', 'x_api_version', x_api_version)
            // verify required parameter 'FetchReconRequest' is not null or undefined
            assertParamExists('pGFetchRecon', 'FetchReconRequest', FetchReconRequest)
            const localVarPath = `/recon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(FetchReconRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PGReconciliationApi - functional programming interface
 * @export
 */
const PGReconciliationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PGReconciliationApiAxiosParamCreator(configuration)
    return {
        /**
         * - Use this API to get the payment gateway reconciliation details with date range. - It will have events for your payment account 
         * @summary PG Reconciliation
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {FetchReconRequest} FetchReconRequest Request Body for the reconciliation
         * @param {string} [Content_Type] application/json
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [Accept] application/json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGFetchRecon(x_api_version: string, FetchReconRequest: FetchReconRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReconEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGFetchRecon(x_api_version, FetchReconRequest, Content_Type, x_request_id, x_idempotency_key, Accept, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * PGReconciliationApi - object-oriented interface
 * @export
 * @class PGReconciliationApi
 * @extends {BaseAPI}
 */



/**
 * PaymentLinksApi - axios parameter creator
 * @export
 */
const PaymentLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to cancel a payment link. No further payments can be done against a cancelled link. Only a link in ACTIVE status can be cancelled.
         * @summary Cancel Payment Link
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} link_id The payment link ID for which you want to view the details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGCancelLink: async (x_api_version: string, link_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCancelLink', 'x_api_version', x_api_version)
            // verify required parameter 'link_id' is not null or undefined
            assertParamExists('pGCancelLink', 'link_id', link_id)
            const localVarPath = `/links/{link_id}/cancel`
                .replace(`{${"link_id"}}`, encodeURIComponent(String(link_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a new payment link. The created payment link url will be available in the API response parameter link_url.
         * @summary Create Payment Link
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateLinkRequest} CreateLinkRequest Request Body to Create Payment Links
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGCreateLink: async (x_api_version: string, CreateLinkRequest: CreateLinkRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCreateLink', 'x_api_version', x_api_version)
            // verify required parameter 'CreateLinkRequest' is not null or undefined
            assertParamExists('pGCreateLink', 'CreateLinkRequest', CreateLinkRequest)
            const localVarPath = `/links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to view all details and status of a payment link.
         * @summary Fetch Payment Link Details
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} link_id The payment link ID for which you want to view the details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGFetchLink: async (x_api_version: string, link_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGFetchLink', 'x_api_version', x_api_version)
            // verify required parameter 'link_id' is not null or undefined
            assertParamExists('pGFetchLink', 'link_id', link_id)
            const localVarPath = `/links/{link_id}`
                .replace(`{${"link_id"}}`, encodeURIComponent(String(link_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to view all order details for a payment link.
         * @summary Get Orders for a Payment Link
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} link_id The payment link ID for which you want to view the details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGLinkFetchOrders: async (x_api_version: string, link_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGLinkFetchOrders', 'x_api_version', x_api_version)
            // verify required parameter 'link_id' is not null or undefined
            assertParamExists('pGLinkFetchOrders', 'link_id', link_id)
            const localVarPath = `/links/{link_id}/orders`
                .replace(`{${"link_id"}}`, encodeURIComponent(String(link_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentLinksApi - functional programming interface
 * @export
 */
const PaymentLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to cancel a payment link. No further payments can be done against a cancelled link. Only a link in ACTIVE status can be cancelled.
         * @summary Cancel Payment Link
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} link_id The payment link ID for which you want to view the details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCancelLink(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCancelLink(x_api_version, link_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to create a new payment link. The created payment link url will be available in the API response parameter link_url.
         * @summary Create Payment Link
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateLinkRequest} CreateLinkRequest Request Body to Create Payment Links
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCreateLink(x_api_version: string, CreateLinkRequest: CreateLinkRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCreateLink(x_api_version, CreateLinkRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to view all details and status of a payment link.
         * @summary Fetch Payment Link Details
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} link_id The payment link ID for which you want to view the details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGFetchLink(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGFetchLink(x_api_version, link_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to view all order details for a payment link.
         * @summary Get Orders for a Payment Link
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} link_id The payment link ID for which you want to view the details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGLinkFetchOrders(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentLinkOrderEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGLinkFetchOrders(x_api_version, link_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * PaymentLinksApi - object-oriented interface
 * @export
 * @class PaymentLinksApi
 * @extends {BaseAPI}
 */



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to capture or void a preauthorized payment
         * @summary Preauthorization
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {AuthorizeOrderRequest} AuthorizeOrderRequest Request to Capture or Void Transactions
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGAuthorizeOrder: async (x_api_version: string, order_id: string, AuthorizeOrderRequest: AuthorizeOrderRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGAuthorizeOrder', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGAuthorizeOrder', 'order_id', order_id)
            // verify required parameter 'AuthorizeOrderRequest' is not null or undefined
            assertParamExists('pGAuthorizeOrder', 'AuthorizeOrderRequest', AuthorizeOrderRequest)
            const localVarPath = `/orders/{order_id}/authorization`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(AuthorizeOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you accept OTP on your own page, you can use the below API to send OTP to Cashfree.
         * @summary Submit or Resend OTP
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_payment_id The Cashfree payment or transaction ID.
         * @param {OrderAuthenticatePaymentRequest} OrderAuthenticatePaymentRequest Request body to submit/resend headless OTP. To use this API make sure you have headless OTP enabled for your account
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGOrderAuthenticatePayment: async (x_api_version: string, cf_payment_id: string, OrderAuthenticatePaymentRequest: OrderAuthenticatePaymentRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderAuthenticatePayment', 'x_api_version', x_api_version)
            // verify required parameter 'cf_payment_id' is not null or undefined
            assertParamExists('pGOrderAuthenticatePayment', 'cf_payment_id', cf_payment_id)
            // verify required parameter 'OrderAuthenticatePaymentRequest' is not null or undefined
            assertParamExists('pGOrderAuthenticatePayment', 'OrderAuthenticatePaymentRequest', OrderAuthenticatePaymentRequest)
            const localVarPath = `/orders/pay/authenticate/{cf_payment_id}`
                .replace(`{${"cf_payment_id"}}`, encodeURIComponent(String(cf_payment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(OrderAuthenticatePaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to view payment details of an order for a payment ID.
         * @summary Get Payment by ID
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} cf_payment_id The Cashfree payment or transaction ID.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGOrderFetchPayment: async (x_api_version: string, order_id: string, cf_payment_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderFetchPayment', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGOrderFetchPayment', 'order_id', order_id)
            // verify required parameter 'cf_payment_id' is not null or undefined
            assertParamExists('pGOrderFetchPayment', 'cf_payment_id', cf_payment_id)
            const localVarPath = `/orders/{order_id}/payments/{cf_payment_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)))
                .replace(`{${"cf_payment_id"}}`, encodeURIComponent(String(cf_payment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to view all payment details for an order.
         * @summary Get Payments for an Order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGOrderFetchPayments: async (x_api_version: string, order_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderFetchPayments', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGOrderFetchPayments', 'order_id', order_id)
            const localVarPath = `/orders/{order_id}/payments`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API when you have already created the orders and want Cashfree to process the payment. To use this API S2S flag needs to be enabled from the backend. In case you want to use the cards payment option the PCI DSS flag is required, for more information send an email to \"care@cashfree.com\". 
         * @summary Order Pay
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {PayOrderRequest} PayOrderRequest Request body to create a transaction at cashfree using &#x60;payment_session_id&#x60;
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGPayOrder: async (x_api_version: string, PayOrderRequest: PayOrderRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGPayOrder', 'x_api_version', x_api_version)
            // verify required parameter 'PayOrderRequest' is not null or undefined
            assertParamExists('pGPayOrder', 'PayOrderRequest', PayOrderRequest)
            const localVarPath = `/orders/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PayOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to capture or void a preauthorized payment
         * @summary Preauthorization
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {AuthorizeOrderRequest} AuthorizeOrderRequest Request to Capture or Void Transactions
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGAuthorizeOrder(x_api_version: string, order_id: string, AuthorizeOrderRequest: AuthorizeOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGAuthorizeOrder(x_api_version, order_id, AuthorizeOrderRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * If you accept OTP on your own page, you can use the below API to send OTP to Cashfree.
         * @summary Submit or Resend OTP
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_payment_id The Cashfree payment or transaction ID.
         * @param {OrderAuthenticatePaymentRequest} OrderAuthenticatePaymentRequest Request body to submit/resend headless OTP. To use this API make sure you have headless OTP enabled for your account
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderAuthenticatePayment(x_api_version: string, cf_payment_id: string, OrderAuthenticatePaymentRequest: OrderAuthenticatePaymentRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderAuthenticateEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderAuthenticatePayment(x_api_version, cf_payment_id, OrderAuthenticatePaymentRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to view payment details of an order for a payment ID.
         * @summary Get Payment by ID
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} cf_payment_id The Cashfree payment or transaction ID.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderFetchPayment(x_api_version: string, order_id: string, cf_payment_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderFetchPayment(x_api_version, order_id, cf_payment_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to view all payment details for an order.
         * @summary Get Payments for an Order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderFetchPayments(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderFetchPayments(x_api_version, order_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API when you have already created the orders and want Cashfree to process the payment. To use this API S2S flag needs to be enabled from the backend. In case you want to use the cards payment option the PCI DSS flag is required, for more information send an email to \"care@cashfree.com\". 
         * @summary Order Pay
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {PayOrderRequest} PayOrderRequest Request body to create a transaction at cashfree using &#x60;payment_session_id&#x60;
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGPayOrder(x_api_version: string, PayOrderRequest: PayOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayOrderEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGPayOrder(x_api_version, PayOrderRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */



/**
 * RefundsApi - axios parameter creator
 * @export
 */
const RefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to initiate refunds.
         * @summary Create Refund
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {OrderCreateRefundRequest} OrderCreateRefundRequest Request Body to Create Refunds
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGOrderCreateRefund: async (x_api_version: string, order_id: string, OrderCreateRefundRequest: OrderCreateRefundRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderCreateRefund', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGOrderCreateRefund', 'order_id', order_id)
            // verify required parameter 'OrderCreateRefundRequest' is not null or undefined
            assertParamExists('pGOrderCreateRefund', 'OrderCreateRefundRequest', OrderCreateRefundRequest)
            const localVarPath = `/orders/{order_id}/refunds`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(OrderCreateRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch a specific refund processed on your Cashfree Account.
         * @summary Get Refund
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} refund_id Refund Id of the refund you want to fetch.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGOrderFetchRefund: async (x_api_version: string, order_id: string, refund_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderFetchRefund', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGOrderFetchRefund', 'order_id', order_id)
            // verify required parameter 'refund_id' is not null or undefined
            assertParamExists('pGOrderFetchRefund', 'refund_id', refund_id)
            const localVarPath = `/orders/{order_id}/refunds/{refund_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)))
                .replace(`{${"refund_id"}}`, encodeURIComponent(String(refund_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch all refunds processed against an order.
         * @summary Get All Refunds for an Order
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGOrderFetchRefunds: async (x_api_version: string, order_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderFetchRefunds', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGOrderFetchRefunds', 'order_id', order_id)
            const localVarPath = `/orders/{order_id}/refunds`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundsApi - functional programming interface
 * @export
 */
const RefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to initiate refunds.
         * @summary Create Refund
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {OrderCreateRefundRequest} OrderCreateRefundRequest Request Body to Create Refunds
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderCreateRefund(x_api_version: string, order_id: string, OrderCreateRefundRequest: OrderCreateRefundRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderCreateRefund(x_api_version, order_id, OrderCreateRefundRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to fetch a specific refund processed on your Cashfree Account.
         * @summary Get Refund
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} refund_id Refund Id of the refund you want to fetch.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderFetchRefund(x_api_version: string, order_id: string, refund_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderFetchRefund(x_api_version, order_id, refund_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to fetch all refunds processed against an order.
         * @summary Get All Refunds for an Order
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderFetchRefunds(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderFetchRefunds(x_api_version, order_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * RefundsApi - object-oriented interface
 * @export
 * @class RefundsApi
 * @extends {BaseAPI}
 */



/**
 * SettlementReconciliationApi - axios parameter creator
 * @export
 */
const SettlementReconciliationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to get all settlement details by specifying the settlement ID, settlement UTR or date range.
         * @summary Get All Settlements
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {FetchSettlementsRequest} FetchSettlementsRequest Request Body to get the settlements
         * @param {string} [Content_Type] application/json
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [Accept] application/json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGFetchSettlements: async (x_api_version: string, FetchSettlementsRequest: FetchSettlementsRequest,  Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGFetchSettlements', 'x_api_version', x_api_version)
            // verify required parameter 'FetchSettlementsRequest' is not null or undefined
            assertParamExists('pGFetchSettlements', 'FetchSettlementsRequest', FetchSettlementsRequest)
            const localVarPath = `/settlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(FetchSettlementsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Use this API to get settlement reconciliation details using Settlement ID, settlement UTR or date range. - This API will return events for the settlement IDs you want 
         * @summary Settlement Reconciliation
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {SettlementFetchReconRequest} SettlementFetchReconRequest Request Body for the settlement reconciliation
         * @param {string} [Content_Type] application/json
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [Accept] application/json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGSettlementFetchRecon: async (x_api_version: string, SettlementFetchReconRequest: SettlementFetchReconRequest,  Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGSettlementFetchRecon', 'x_api_version', x_api_version)
            // verify required parameter 'SettlementFetchReconRequest' is not null or undefined
            assertParamExists('pGSettlementFetchRecon', 'SettlementFetchReconRequest', SettlementFetchReconRequest)
            const localVarPath = `/settlement/recon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(SettlementFetchReconRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettlementReconciliationApi - functional programming interface
 * @export
 */
const SettlementReconciliationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettlementReconciliationApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to get all settlement details by specifying the settlement ID, settlement UTR or date range.
         * @summary Get All Settlements
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {FetchSettlementsRequest} FetchSettlementsRequest Request Body to get the settlements
         * @param {string} [Content_Type] application/json
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [Accept] application/json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGFetchSettlements(x_api_version: string, FetchSettlementsRequest: FetchSettlementsRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGFetchSettlements(x_api_version, FetchSettlementsRequest, Content_Type, x_request_id, x_idempotency_key, Accept, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * - Use this API to get settlement reconciliation details using Settlement ID, settlement UTR or date range. - This API will return events for the settlement IDs you want 
         * @summary Settlement Reconciliation
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {SettlementFetchReconRequest} SettlementFetchReconRequest Request Body for the settlement reconciliation
         * @param {string} [Content_Type] application/json
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {string} [Accept] application/json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGSettlementFetchRecon(x_api_version: string, SettlementFetchReconRequest: SettlementFetchReconRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementReconEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGSettlementFetchRecon(x_api_version, SettlementFetchReconRequest, Content_Type, x_request_id, x_idempotency_key, Accept, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * SettlementReconciliationApi - object-oriented interface
 * @export
 * @class SettlementReconciliationApi
 * @extends {BaseAPI}
 */



/**
 * SettlementsApi - axios parameter creator
 * @export
 */
const SettlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to view all the settlements of a particular order.
         * @summary Get Settlements by Order ID
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        pGOrderFetchSettlement: async (x_api_version: string, order_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGOrderFetchSettlement', 'x_api_version', x_api_version)
            // verify required parameter 'order_id' is not null or undefined
            assertParamExists('pGOrderFetchSettlement', 'order_id', order_id)
            const localVarPath = `/orders/{order_id}/settlements`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettlementsApi - functional programming interface
 * @export
 */
const SettlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to view all the settlements of a particular order.
         * @summary Get Settlements by Order ID
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} order_id The id which uniquely identifies your order
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGOrderFetchSettlement(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGOrderFetchSettlement(x_api_version, order_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * SettlementsApi - object-oriented interface
 * @export
 * @class SettlementsApi
 * @extends {BaseAPI}
 */



/**
 * SoftPOSApi - axios parameter creator
 * @export
 */
const SoftPOSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to create new terminals to use softPOS.
         * @summary Create Terminal
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateTerminalRequest} CreateTerminalRequest Request Body to Create Terminal for SPOS
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        sposCreateTerminal: async (x_api_version: string, CreateTerminalRequest: CreateTerminalRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposCreateTerminal', 'x_api_version', x_api_version)
            // verify required parameter 'CreateTerminalRequest' is not null or undefined
            assertParamExists('sposCreateTerminal', 'CreateTerminalRequest', CreateTerminalRequest)
            const localVarPath = `/terminal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateTerminalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a new terminal transaction. To use this API you should first create an order using the Create Order API. Also, you need to enter the terminal details while creating the order and pass the same terminal information while creating a transaction using the below mentioned API.
         * @summary Create Terminal Transaction
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateTerminalTransactionRequest} CreateTerminalTransactionRequest Request body to create a terminal transaction
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        sposCreateTerminalTransaction: async (x_api_version: string, CreateTerminalTransactionRequest: CreateTerminalTransactionRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposCreateTerminalTransaction', 'x_api_version', x_api_version)
            // verify required parameter 'CreateTerminalTransactionRequest' is not null or undefined
            assertParamExists('sposCreateTerminalTransaction', 'CreateTerminalTransactionRequest', CreateTerminalTransactionRequest)
            const localVarPath = `/terminal/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateTerminalTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to view all details of a terminal.
         * @summary Get Terminal Status using Phone Number
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} terminal_phone_no The terminal for which you want to view the order details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_idempotency_key?: string, 
         */
        sposFetchTerminal: async (x_api_version: string, terminal_phone_no: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposFetchTerminal', 'x_api_version', x_api_version)
            // verify required parameter 'terminal_phone_no' is not null or undefined
            assertParamExists('sposFetchTerminal', 'terminal_phone_no', terminal_phone_no)
            const localVarPath = `/terminal/{terminal_phone_no}`
                .replace(`{${"terminal_phone_no"}}`, encodeURIComponent(String(terminal_phone_no)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can fetch all the StaticQRs corresponding to given terminal id or phone number. Provide either the terminal_phone_no or terminal_id in the request.
         * @summary Fetch Terminal QR Codes
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} terminal_phone_no Phone number assigned to the terminal. Required if you are not providing the cf_terminal_id in the request.
         * @param {string} cf_terminal_id Cashfree terminal id for which you want to get staticQRs. Required if you are not providing the terminal_phone_number in the request.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        sposFetchTerminalQRCodes: async (x_api_version: string, terminal_phone_no: string, cf_terminal_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposFetchTerminalQRCodes', 'x_api_version', x_api_version)
            // verify required parameter 'terminal_phone_no' is not null or undefined
            assertParamExists('sposFetchTerminalQRCodes', 'terminal_phone_no', terminal_phone_no)
            // verify required parameter 'cf_terminal_id' is not null or undefined
            assertParamExists('sposFetchTerminalQRCodes', 'cf_terminal_id', cf_terminal_id)
            const localVarPath = `/terminal/qrcodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")

            if (terminal_phone_no !== undefined) {
                localVarQueryParameter['terminal_phone_no'] = terminal_phone_no;
            }

            if (cf_terminal_id !== undefined) {
                localVarQueryParameter['cf_terminal_id'] = cf_terminal_id;
            }


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get  terminal transaction.
         * @summary Get Terminal Transaction
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} utr Utr of the transaction.
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        sposFetchTerminalTransaction: async (x_api_version: string, utr: string, cf_terminal_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposFetchTerminalTransaction', 'x_api_version', x_api_version)
            // verify required parameter 'utr' is not null or undefined
            assertParamExists('sposFetchTerminalTransaction', 'utr', utr)
            // verify required parameter 'cf_terminal_id' is not null or undefined
            assertParamExists('sposFetchTerminalTransaction', 'cf_terminal_id', cf_terminal_id)
            const localVarPath = `/terminal/{cf_terminal_id}/payments`
                .replace(`{${"cf_terminal_id"}}`, encodeURIComponent(String(cf_terminal_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")

            if (utr !== undefined) {
                localVarQueryParameter['utr'] = utr;
            }


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update the terminal details. Email, Phone Number, and Terminal Meta are updatable for \"Storefront\". Only account status change is possible in case of \"Agent\".
         * @summary Update Terminal
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {UpdateTerminalRequest} UpdateTerminalRequest Request Body to update terminal for SPOS.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        sposUpdateTerminal: async (x_api_version: string, cf_terminal_id: string, UpdateTerminalRequest: UpdateTerminalRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposUpdateTerminal', 'x_api_version', x_api_version)
            // verify required parameter 'cf_terminal_id' is not null or undefined
            assertParamExists('sposUpdateTerminal', 'cf_terminal_id', cf_terminal_id)
            // verify required parameter 'UpdateTerminalRequest' is not null or undefined
            assertParamExists('sposUpdateTerminal', 'UpdateTerminalRequest', UpdateTerminalRequest)
            const localVarPath = `/terminal/{cf_terminal_id}`
                .replace(`{${"cf_terminal_id"}}`, encodeURIComponent(String(cf_terminal_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateTerminalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update the terminal status.
         * @summary Update Terminal Status
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {UpdateTerminalStatusRequest} UpdateTerminalStatusRequest Request Body to update terminal status for SPOS.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        sposUpdateTerminalStatus: async (x_api_version: string, cf_terminal_id: string, UpdateTerminalStatusRequest: UpdateTerminalStatusRequest,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposUpdateTerminalStatus', 'x_api_version', x_api_version)
            // verify required parameter 'cf_terminal_id' is not null or undefined
            assertParamExists('sposUpdateTerminalStatus', 'cf_terminal_id', cf_terminal_id)
            // verify required parameter 'UpdateTerminalStatusRequest' is not null or undefined
            assertParamExists('sposUpdateTerminalStatus', 'UpdateTerminalStatusRequest', UpdateTerminalStatusRequest)
            const localVarPath = `/terminal/{cf_terminal_id}/status`
                .replace(`{${"cf_terminal_id"}}`, encodeURIComponent(String(cf_terminal_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateTerminalStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to upload the terminal documents.
         * @summary Upload Terminal Docs
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {UploadTerminalDocs} UploadTerminalDocs Request Body to update terminal documents for SPOS.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        sposUploadTerminalDocs: async (x_api_version: string, cf_terminal_id: string, UploadTerminalDocs: UploadTerminalDocs,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('sposUploadTerminalDocs', 'x_api_version', x_api_version)
            // verify required parameter 'cf_terminal_id' is not null or undefined
            assertParamExists('sposUploadTerminalDocs', 'cf_terminal_id', cf_terminal_id)
            // verify required parameter 'UploadTerminalDocs' is not null or undefined
            assertParamExists('sposUploadTerminalDocs', 'UploadTerminalDocs', UploadTerminalDocs)
            const localVarPath = `/terminal/{cf_terminal_id}/docs`
                .replace(`{${"cf_terminal_id"}}`, encodeURIComponent(String(cf_terminal_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UploadTerminalDocs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SoftPOSApi - functional programming interface
 * @export
 */
const SoftPOSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SoftPOSApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to create new terminals to use softPOS.
         * @summary Create Terminal
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateTerminalRequest} CreateTerminalRequest Request Body to Create Terminal for SPOS
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposCreateTerminal(x_api_version: string, CreateTerminalRequest: CreateTerminalRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminalEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposCreateTerminal(x_api_version, CreateTerminalRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to create a new terminal transaction. To use this API you should first create an order using the Create Order API. Also, you need to enter the terminal details while creating the order and pass the same terminal information while creating a transaction using the below mentioned API.
         * @summary Create Terminal Transaction
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {CreateTerminalTransactionRequest} CreateTerminalTransactionRequest Request body to create a terminal transaction
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposCreateTerminalTransaction(x_api_version: string, CreateTerminalTransactionRequest: CreateTerminalTransactionRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminalTransactionEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposCreateTerminalTransaction(x_api_version, CreateTerminalTransactionRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to view all details of a terminal.
         * @summary Get Terminal Status using Phone Number
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} terminal_phone_no The terminal for which you want to view the order details.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposFetchTerminal(x_api_version: string, terminal_phone_no: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminalEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposFetchTerminal(x_api_version, terminal_phone_no, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * You can fetch all the StaticQRs corresponding to given terminal id or phone number. Provide either the terminal_phone_no or terminal_id in the request.
         * @summary Fetch Terminal QR Codes
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} terminal_phone_no Phone number assigned to the terminal. Required if you are not providing the cf_terminal_id in the request.
         * @param {string} cf_terminal_id Cashfree terminal id for which you want to get staticQRs. Required if you are not providing the terminal_phone_number in the request.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposFetchTerminalQRCodes(x_api_version: string, terminal_phone_no: string, cf_terminal_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FetchTerminalQRCodesEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposFetchTerminalQRCodes(x_api_version, terminal_phone_no, cf_terminal_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to get  terminal transaction.
         * @summary Get Terminal Transaction
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} utr Utr of the transaction.
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposFetchTerminalTransaction(x_api_version: string, utr: string, cf_terminal_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminalPaymentEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposFetchTerminalTransaction(x_api_version, utr, cf_terminal_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to update the terminal details. Email, Phone Number, and Terminal Meta are updatable for \"Storefront\". Only account status change is possible in case of \"Agent\".
         * @summary Update Terminal
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {UpdateTerminalRequest} UpdateTerminalRequest Request Body to update terminal for SPOS.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposUpdateTerminal(x_api_version: string, cf_terminal_id: string, UpdateTerminalRequest: UpdateTerminalRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateTerminalEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposUpdateTerminal(x_api_version, cf_terminal_id, UpdateTerminalRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to update the terminal status.
         * @summary Update Terminal Status
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {UpdateTerminalStatusRequest} UpdateTerminalStatusRequest Request Body to update terminal status for SPOS.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposUpdateTerminalStatus(x_api_version: string, cf_terminal_id: string, UpdateTerminalStatusRequest: UpdateTerminalStatusRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateTerminalEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposUpdateTerminalStatus(x_api_version, cf_terminal_id, UpdateTerminalStatusRequest, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to upload the terminal documents.
         * @summary Upload Terminal Docs
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
         * @param {UploadTerminalDocs} UploadTerminalDocs Request Body to update terminal documents for SPOS.
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sposUploadTerminalDocs(x_api_version: string, cf_terminal_id: string, UploadTerminalDocs: UploadTerminalDocs, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadTerminalDocsEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.sposUploadTerminalDocs(x_api_version, cf_terminal_id, UploadTerminalDocs, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * SoftPOSApi - object-oriented interface
 * @export
 * @class SoftPOSApi
 * @extends {BaseAPI}
 */



/**
 * TokenVaultApi - axios parameter creator
 * @export
 */
const TokenVaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to delete a saved card instrument for a customer_id and instrument_id
         * @summary Delete Saved Card Instrument
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {string} instrument_id The instrument_id which needs to be deleted
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGCustomerDeleteInstrument: async (x_api_version: string, customer_id: string, instrument_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCustomerDeleteInstrument', 'x_api_version', x_api_version)
            // verify required parameter 'customer_id' is not null or undefined
            assertParamExists('pGCustomerDeleteInstrument', 'customer_id', customer_id)
            // verify required parameter 'instrument_id' is not null or undefined
            assertParamExists('pGCustomerDeleteInstrument', 'instrument_id', instrument_id)
            const localVarPath = `/customers/{customer_id}/instruments/{instrument_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customer_id)))
                .replace(`{${"instrument_id"}}`, encodeURIComponent(String(instrument_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch a single specific saved card for a customer_id by it\'s instrument_id
         * @summary Fetch Specific Saved Card Instrument
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {string} instrument_id The instrument_id of the saved instrument which needs to be queried
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGCustomerFetchInstrument: async (x_api_version: string, customer_id: string, instrument_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCustomerFetchInstrument', 'x_api_version', x_api_version)
            // verify required parameter 'customer_id' is not null or undefined
            assertParamExists('pGCustomerFetchInstrument', 'customer_id', customer_id)
            // verify required parameter 'instrument_id' is not null or undefined
            assertParamExists('pGCustomerFetchInstrument', 'instrument_id', instrument_id)
            const localVarPath = `/customers/{customer_id}/instruments/{instrument_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customer_id)))
                .replace(`{${"instrument_id"}}`, encodeURIComponent(String(instrument_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch saved cards for a customer_id 
         * @summary Fetch All Saved Card Instrument
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {PGCustomerFetchInstrumentsInstrumentTypeEnum} instrument_type Payment mode or type of saved instrument 
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGCustomerFetchInstruments: async (x_api_version: string, customer_id: string, instrument_type: PGCustomerFetchInstrumentsInstrumentTypeEnum,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCustomerFetchInstruments', 'x_api_version', x_api_version)
            // verify required parameter 'customer_id' is not null or undefined
            assertParamExists('pGCustomerFetchInstruments', 'customer_id', customer_id)
            // verify required parameter 'instrument_type' is not null or undefined
            assertParamExists('pGCustomerFetchInstruments', 'instrument_type', instrument_type)
            const localVarPath = `/customers/{customer_id}/instruments`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customer_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")

            if (instrument_type !== undefined) {
                localVarQueryParameter['instrument_type'] = instrument_type;
            }


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API To get the card network token, token expiry and cryptogram for a saved card instrument using instrument id
         * @summary Fetch cryptogram for a saved card instrument
         
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {string} instrument_id The instrument_id of the saved card instrument which needs to be queried
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * x_request_id?: string, 
         */
        pGCustomerInstrumentsFetchCryptogram: async (x_api_version: string, customer_id: string, instrument_id: string,  x_request_id?: string, x_idempotency_key?: string,  options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x_api_version' is not null or undefined
            assertParamExists('pGCustomerInstrumentsFetchCryptogram', 'x_api_version', x_api_version)
            // verify required parameter 'customer_id' is not null or undefined
            assertParamExists('pGCustomerInstrumentsFetchCryptogram', 'customer_id', customer_id)
            // verify required parameter 'instrument_id' is not null or undefined
            assertParamExists('pGCustomerInstrumentsFetchCryptogram', 'instrument_id', instrument_id)
            const localVarPath = `/customers/{customer_id}/instruments/{instrument_id}/cryptogram`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customer_id)))
                .replace(`{${"instrument_id"}}`, encodeURIComponent(String(instrument_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            var url = "https://sandbox.cashfree.com/pg";
            if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                url = "https://api.cashfree.com/pg"
            }
            const localVarUrlObj = new URL(localVarPath, url);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XPartnerAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-apikey")

            // authentication XClientSecret required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-secret")

            // authentication XPartnerMerchantID required
            await setApiKeyToObject(localVarHeaderParameter, "x-partner-merchantid")

            // authentication XClientID required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-id")

            // authentication XClientSignatureHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-client-signature")


    
            localVarHeaderParameter['x-sdk-platform'] = 'nodejssdk-4.1.2';
            if (x_api_version != null && x_api_version != undefined) {
                localVarHeaderParameter['x-api-version'] = x_api_version;
            }

            if (x_request_id != null && x_request_id != undefined) {
                localVarHeaderParameter['x-request-id'] = x_request_id;
            }

            if (x_idempotency_key != null && x_idempotency_key != undefined) {
                localVarHeaderParameter['x-idempotency-key'] = x_idempotency_key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenVaultApi - functional programming interface
 * @export
 */
const TokenVaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenVaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to delete a saved card instrument for a customer_id and instrument_id
         * @summary Delete Saved Card Instrument
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {string} instrument_id The instrument_id which needs to be deleted
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCustomerDeleteInstrument(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstrumentEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCustomerDeleteInstrument(x_api_version, customer_id, instrument_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to fetch a single specific saved card for a customer_id by it\'s instrument_id
         * @summary Fetch Specific Saved Card Instrument
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {string} instrument_id The instrument_id of the saved instrument which needs to be queried
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCustomerFetchInstrument(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstrumentEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCustomerFetchInstrument(x_api_version, customer_id, instrument_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API to fetch saved cards for a customer_id 
         * @summary Fetch All Saved Card Instrument
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {PGCustomerFetchInstrumentsInstrumentTypeEnum} instrument_type Payment mode or type of saved instrument 
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCustomerFetchInstruments(x_api_version: string, customer_id: string, instrument_type: PGCustomerFetchInstrumentsInstrumentTypeEnum, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstrumentEntity>>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCustomerFetchInstruments(x_api_version, customer_id, instrument_type, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
        /**
         * Use this API To get the card network token, token expiry and cryptogram for a saved card instrument using instrument id
         * @summary Fetch cryptogram for a saved card instrument
         * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
         * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
         * @param {string} instrument_id The instrument_id of the saved card instrument which needs to be queried
         * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
         * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pGCustomerInstrumentsFetchCryptogram(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptogramEntity>> {
                const localVarAxiosArgs = await localVarAxiosParamCreator.pGCustomerInstrumentsFetchCryptogram(x_api_version, customer_id, instrument_id, x_request_id, x_idempotency_key, options);
                var url = "https://sandbox.cashfree.com/pg";
                if(Cashfree.XEnvironment == CFEnvironment.PRODUCTION) {
                    url = "https://api.cashfree.com/pg"
                }
                return createRequestFunction(localVarAxiosArgs, globalAxios, url, configuration);
        },
    }
};

/**
 * TokenVaultApi - object-oriented interface
 * @export
 * @class TokenVaultApi
 * @extends {BaseAPI}
 */

/**
 * @export
 */
export const PGCustomerFetchInstrumentsInstrumentTypeEnum = {
    CARD: 'card',
    UNKNOWN_DEFAULT_OPEN_API: '11184809'
} as const;
export type PGCustomerFetchInstrumentsInstrumentTypeEnum = typeof PGCustomerFetchInstrumentsInstrumentTypeEnum[keyof typeof PGCustomerFetchInstrumentsInstrumentTypeEnum];



class Environment {
    public PRODUCTION = CFEnvironment.PRODUCTION;
    public SANDBOX = CFEnvironment.SANDBOX;
}

export class PGWebhookEvent {

    type: string;
    raw: string;
    object: any;

    constructor(type: string, rawBody: string, object: any) {
        this.type = type;
        this.raw = rawBody
        this.object = object;
    }
}

export class Cashfree {
    static axios: AxiosInstance;
    static basePath: string;

    static XClientId?: string;
    static XClientSecret?: string;
    static XPartnerKey?: string;
    static XClientSignature?: string;
    static XPartnerMerchantId?: string;
    static XEnvironment: CFEnvironment;
    static XEnableErrorAnalytics: boolean = true;
    static XApiVersion: string = "2023-08-01";

    static Environment = new Environment();

    /**
     * Use this API to verify your webhook signature once you receive from Cashfree's server.
     * @summary Verify Webhook Signatures
     * @param {string} signature that is present in the header of the webhook ("x-webhook-signature")
     * @param {string} rawBody is the entire body sent to the server in string format
     * @param {string} timestamp that is present in the header of the webhook ("x-webhook-timestamp")
     * @throws {Error}
     */
    public static PGVerifyWebhookSignature(signature: string, rawBody: string, timestamp: string) {
        const body = timestamp + rawBody
        const secretKey = Cashfree.XClientSecret;
        let generatedSignature = crypto.createHmac('sha256', secretKey).update(body).digest("base64");
        if(generatedSignature === signature) {
            let jsonObject = JSON.parse(rawBody)
            return new PGWebhookEvent(jsonObject.type, rawBody, jsonObject);
        }
        throw new Error("Generated signature and received signature did not match.");
    }

    
    /**
     * Create Customer at Cashfree
     * @summary Create Customer at Cashfree
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateCustomerRequest} CreateCustomerRequest Request to create a new customer at Cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public static PGCreateCustomer(x_api_version: string, CreateCustomerRequest: CreateCustomerRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return CustomersApiFp().pGCreateCustomer(x_api_version, CreateCustomerRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * The Create On Demand Transfer API will create a new on-demand request either from to the merchant or from to the vendor.
     * @summary Create On Demand Transfer
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} vendor_id The id which uniquely identifies your vendor.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {AdjustVendorBalanceRequest} [AdjustVendorBalanceRequest] Adjust Vendor Balance Request Body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESCreateOnDemandTransfer(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, AdjustVendorBalanceRequest?: AdjustVendorBalanceRequest, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESCreateOnDemandTransfer(x_api_version, vendor_id, x_request_id, x_idempotency_key, AdjustVendorBalanceRequest, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to create a new vendor to your EasySplit account along with the KYC details. Provide KYC details such as account_type, business_type, gst, cin, pan, passport number and so on.
     * @summary Create vendor
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {CreateVendorRequest} [CreateVendorRequest] Create Vendor Request Body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESCreateVendors(x_api_version: string, x_request_id?: string, x_idempotency_key?: string, CreateVendorRequest?: CreateVendorRequest, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESCreateVendors(x_api_version, x_request_id, x_idempotency_key, CreateVendorRequest, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to download the uploaded KYC documents of that particular vendor. Provide the document type. Click the link from the sample request to download the KYC document.
     * @summary Download Vendor Documents
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} doc_type Mention the document type that has to be downloaded. Only an uploaded document can be downloaded.
     * @param {string} vendor_id The id which uniquely identifies your vendor.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESDownloadVendorsDocs(x_api_version: string, doc_type: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESDownloadVendorsDocs(x_api_version, doc_type, vendor_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to get the details of a specific vendor associated with your Easy Split account.
     * @summary Get Vendor All Details
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} vendor_id The id which uniquely identifies your vendor.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESFetchVendors(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESFetchVendors(x_api_version, vendor_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * This API fetches the available amount with the merchant, vendor, and the unsettled amount for the merchant as well as the vendor.
     * @summary Get On Demand Balance
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} vendor_id The id which uniquely identifies your vendor.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESGetVendorBalance(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESGetVendorBalance(x_api_version, vendor_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * This API returns the applicable service charge and service tax for a vendor balance transfer, based on the provided amount and rate type.
     * @summary Get Vendor Balance Transfer Charges
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {number} amount Specify the amount for which you want to view the service charges and service taxes in the response.
     * @param {string} rate_type Mention the type of rate for which you want to check the charges. Possible value: VENDOR_ON_DEMAND
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESGetVendorBalanceTransferCharges(x_api_version: string, amount: number, rate_type: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESGetVendorBalanceTransferCharges(x_api_version, amount, rate_type, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to fetch the details of all the KYC details of a particular vendor.
     * @summary Get Vendor All Documents Status
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} vendor_id The id which uniquely identifies your vendor.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESGetVendorsDocs(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESGetVendorsDocs(x_api_version, vendor_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to get all the split details, settled and unsettled transactions details of each vendor who were part of a particular order by providing order Id or start date and end date.
     * @summary Get Split and Settlement Details by OrderID v2.0
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {ESOrderReconRequest} [ESOrderReconRequest] Get Split and Settlement Details by OrderID v2.0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESOrderRecon(x_api_version: string, x_request_id?: string, x_idempotency_key?: string, ESOrderReconRequest?: ESOrderReconRequest, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESOrderRecon(x_api_version, x_request_id, x_idempotency_key, ESOrderReconRequest, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to edit the existing vendor details added to your EasySplit account. You can edit vendor details such as name, email, phone number, upi details, and any of the KYC details.
     * @summary Update vendor Details
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} vendor_id The id which uniquely identifies your vendor.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {UpdateVendorRequest} [UpdateVendorRequest] Create Vendor Request Body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESUpdateVendors(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, UpdateVendorRequest?: UpdateVendorRequest, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESUpdateVendors(x_api_version, vendor_id, x_request_id, x_idempotency_key, UpdateVendorRequest, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to upload KYC documents of a specific vendor.
     * @summary Upload Vendor Docs
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} vendor_id The id which uniquely identifies your vendor.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {string} [doc_type] Mention the type of the document you are uploading. Possible values: UIDAI_FRONT, UIDAI_BACK, UIDAI_NUMBER, DL, DL_NUMBER, PASSPORT_FRONT, PASSPORT_BACK, PASSPORT_NUMBER, VOTER_ID, VOTER_ID_NUMBER, PAN, PAN_NUMBER, GST, GSTIN_NUMBER, CIN, CIN_NUMBER, NBFC_CERTIFICATE. If the doc type ends with a number you should add the doc value else upload the doc file.
     * @param {string} [doc_value] Enter the display name of the uploaded file.
     * @param {File} [file] Select the document that should be uploaded or provide the path of that file. You cannot upload a file that is more than 2MB in size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGESUploadVendorsDocs(x_api_version: string, vendor_id: string, x_request_id?: string, x_idempotency_key?: string, doc_type?: string, doc_value?: string, file?: File, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGESUploadVendorsDocs(x_api_version, vendor_id, x_request_id, x_idempotency_key, doc_type, doc_value, file, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Split After Payment API splits the payments to vendors after successful payment from the customers.
     * @summary Split After Payment
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {SplitAfterPaymentRequest} [SplitAfterPaymentRequest] Request Body to Create Split for an order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGOrderSplitAfterPayment(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, SplitAfterPaymentRequest?: SplitAfterPaymentRequest, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGOrderSplitAfterPayment(x_api_version, order_id, x_request_id, x_idempotency_key, SplitAfterPaymentRequest, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * This API will create a static split scheme wherein you can define the split type and the vendor-wise split percentage.
     * @summary Create Static Split Configuration
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {StaticSplitRequest} [StaticSplitRequest] Static Split
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasySplitApi
     */
    public static PGOrderStaticSplit(x_api_version: string, x_request_id?: string, x_idempotency_key?: string, StaticSplitRequest?: StaticSplitRequest, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EasySplitApiFp().pGOrderStaticSplit(x_api_version, x_request_id, x_idempotency_key, StaticSplitRequest, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to get eligible Cardless EMI Payment Methods available for a customer on an order basis their phone number.
     * @summary Get Eligible Cardless EMI Payment Methods for a customer on an order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchCardlessEMIRequest} EligibilityFetchCardlessEMIRequest Request Body to get eligible cardless emi options for a customer and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    public static PGEligibilityFetchCardlessEMI(x_api_version: string, EligibilityFetchCardlessEMIRequest: EligibilityFetchCardlessEMIRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EligibilityApiFp().pGEligibilityFetchCardlessEMI(x_api_version, EligibilityFetchCardlessEMIRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to get eligible offers for an order_id or order amount.
     * @summary Get Eligible Offers for an Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchOffersRequest} EligibilityFetchOffersRequest Request Body to get eligible offers for a customer and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    public static PGEligibilityFetchOffers(x_api_version: string, EligibilityFetchOffersRequest: EligibilityFetchOffersRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EligibilityApiFp().pGEligibilityFetchOffers(x_api_version, EligibilityFetchOffersRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to get eligible Paylater Payment Methods for a customer on an order.
     * @summary Get Eligible Paylater for a customer on an order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchPaylaterRequest} EligibilityFetchPaylaterRequest Request Body to get eligible paylater options for a customer and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    public static PGEligibilityFetchPaylater(x_api_version: string, EligibilityFetchPaylaterRequest: EligibilityFetchPaylaterRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EligibilityApiFp().pGEligibilityFetchPaylater(x_api_version, EligibilityFetchPaylaterRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to get eligible Payment Methods
     * @summary Get eligible Payment Methods
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchPaymentMethodsRequest} EligibilityFetchPaymentMethodsRequest Request Body to get eligible payment methods for an account and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    public static PGEligibilityFetchPaymentMethods(x_api_version: string, EligibilityFetchPaymentMethodsRequest: EligibilityFetchPaymentMethodsRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return EligibilityApiFp().pGEligibilityFetchPaymentMethods(x_api_version, EligibilityFetchPaymentMethodsRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to create offers with Cashfree from your backend
     * @summary Create Offer
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateOfferRequest} CreateOfferRequest Request body to create an offer at Cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public static PGCreateOffer(x_api_version: string, CreateOfferRequest: CreateOfferRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return OffersApiFp().pGCreateOffer(x_api_version, CreateOfferRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to get offer by offer_id
     * @summary Get Offer by ID
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} offer_id The offer ID for which you want to view the offer details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public static PGFetchOffer(x_api_version: string, offer_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return OffersApiFp().pGFetchOffer(x_api_version, offer_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * ### Order An order is an entity which has a amount and currency associated with it. It is something for which you want to collect payment for. Use this API to create orders with Cashfree from your backend to get a `payment_sessions_id`.  You can use the `payment_sessions_id` to create a transaction for the order. 
     * @summary Create Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateOrderRequest} CreateOrderRequest Request body to create an order at cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public static PGCreateOrder(x_api_version: string, CreateOrderRequest: CreateOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return OrdersApiFp().pGCreateOrder(x_api_version, CreateOrderRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to fetch the order that was created at Cashfree\'s using the `order_id`.  ## When to use this API - To check the status of your order - Once the order is PAID - Once your customer returns to `return_url` 
     * @summary Get Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public static PGFetchOrder(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return OrdersApiFp().pGFetchOrder(x_api_version, order_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to terminate the order that was created at Cashfree\'s using the `order_id`.
     * @summary Terminate Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {TerminateOrderRequest} TerminateOrderRequest Request body to terminate an order at cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public static PGTerminateOrder(x_api_version: string, order_id: string, TerminateOrderRequest: TerminateOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return OrdersApiFp().pGTerminateOrder(x_api_version, order_id, TerminateOrderRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * - Use this API to get the payment gateway reconciliation details with date range. - It will have events for your payment account 
     * @summary PG Reconciliation
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {FetchReconRequest} FetchReconRequest Request Body for the reconciliation
     * @param {string} [Content_Type] application/json
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {string} [Accept] application/json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PGReconciliationApi
     */
    public static PGFetchRecon(x_api_version: string, FetchReconRequest: FetchReconRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PGReconciliationApiFp().pGFetchRecon(x_api_version, FetchReconRequest, Content_Type, x_request_id, x_idempotency_key, Accept, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to cancel a payment link. No further payments can be done against a cancelled link. Only a link in ACTIVE status can be cancelled.
     * @summary Cancel Payment Link
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} link_id The payment link ID for which you want to view the details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    public static PGCancelLink(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentLinksApiFp().pGCancelLink(x_api_version, link_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to create a new payment link. The created payment link url will be available in the API response parameter link_url.
     * @summary Create Payment Link
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateLinkRequest} CreateLinkRequest Request Body to Create Payment Links
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    public static PGCreateLink(x_api_version: string, CreateLinkRequest: CreateLinkRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentLinksApiFp().pGCreateLink(x_api_version, CreateLinkRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to view all details and status of a payment link.
     * @summary Fetch Payment Link Details
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} link_id The payment link ID for which you want to view the details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    public static PGFetchLink(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentLinksApiFp().pGFetchLink(x_api_version, link_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to view all order details for a payment link.
     * @summary Get Orders for a Payment Link
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} link_id The payment link ID for which you want to view the details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    public static PGLinkFetchOrders(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentLinksApiFp().pGLinkFetchOrders(x_api_version, link_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to capture or void a preauthorized payment
     * @summary Preauthorization
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {AuthorizeOrderRequest} AuthorizeOrderRequest Request to Capture or Void Transactions
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public static PGAuthorizeOrder(x_api_version: string, order_id: string, AuthorizeOrderRequest: AuthorizeOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentsApiFp().pGAuthorizeOrder(x_api_version, order_id, AuthorizeOrderRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * If you accept OTP on your own page, you can use the below API to send OTP to Cashfree.
     * @summary Submit or Resend OTP
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_payment_id The Cashfree payment or transaction ID.
     * @param {OrderAuthenticatePaymentRequest} OrderAuthenticatePaymentRequest Request body to submit/resend headless OTP. To use this API make sure you have headless OTP enabled for your account
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public static PGOrderAuthenticatePayment(x_api_version: string, cf_payment_id: string, OrderAuthenticatePaymentRequest: OrderAuthenticatePaymentRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentsApiFp().pGOrderAuthenticatePayment(x_api_version, cf_payment_id, OrderAuthenticatePaymentRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to view payment details of an order for a payment ID.
     * @summary Get Payment by ID
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} cf_payment_id The Cashfree payment or transaction ID.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public static PGOrderFetchPayment(x_api_version: string, order_id: string, cf_payment_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentsApiFp().pGOrderFetchPayment(x_api_version, order_id, cf_payment_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to view all payment details for an order.
     * @summary Get Payments for an Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public static PGOrderFetchPayments(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentsApiFp().pGOrderFetchPayments(x_api_version, order_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API when you have already created the orders and want Cashfree to process the payment. To use this API S2S flag needs to be enabled from the backend. In case you want to use the cards payment option the PCI DSS flag is required, for more information send an email to \"care@cashfree.com\". 
     * @summary Order Pay
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {PayOrderRequest} PayOrderRequest Request body to create a transaction at cashfree using &#x60;payment_session_id&#x60;
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public static PGPayOrder(x_api_version: string, PayOrderRequest: PayOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return PaymentsApiFp().pGPayOrder(x_api_version, PayOrderRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to initiate refunds.
     * @summary Create Refund
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {OrderCreateRefundRequest} OrderCreateRefundRequest Request Body to Create Refunds
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public static PGOrderCreateRefund(x_api_version: string, order_id: string, OrderCreateRefundRequest: OrderCreateRefundRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return RefundsApiFp().pGOrderCreateRefund(x_api_version, order_id, OrderCreateRefundRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to fetch a specific refund processed on your Cashfree Account.
     * @summary Get Refund
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} refund_id Refund Id of the refund you want to fetch.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public static PGOrderFetchRefund(x_api_version: string, order_id: string, refund_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return RefundsApiFp().pGOrderFetchRefund(x_api_version, order_id, refund_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to fetch all refunds processed against an order.
     * @summary Get All Refunds for an Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public static PGOrderFetchRefunds(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return RefundsApiFp().pGOrderFetchRefunds(x_api_version, order_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to get all settlement details by specifying the settlement ID, settlement UTR or date range.
     * @summary Get All Settlements
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {FetchSettlementsRequest} FetchSettlementsRequest Request Body to get the settlements
     * @param {string} [Content_Type] application/json
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {string} [Accept] application/json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementReconciliationApi
     */
    public static PGFetchSettlements(x_api_version: string, FetchSettlementsRequest: FetchSettlementsRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SettlementReconciliationApiFp().pGFetchSettlements(x_api_version, FetchSettlementsRequest, Content_Type, x_request_id, x_idempotency_key, Accept, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * - Use this API to get settlement reconciliation details using Settlement ID, settlement UTR or date range. - This API will return events for the settlement IDs you want 
     * @summary Settlement Reconciliation
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {SettlementFetchReconRequest} SettlementFetchReconRequest Request Body for the settlement reconciliation
     * @param {string} [Content_Type] application/json
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {string} [Accept] application/json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementReconciliationApi
     */
    public static PGSettlementFetchRecon(x_api_version: string, SettlementFetchReconRequest: SettlementFetchReconRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SettlementReconciliationApiFp().pGSettlementFetchRecon(x_api_version, SettlementFetchReconRequest, Content_Type, x_request_id, x_idempotency_key, Accept, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to view all the settlements of a particular order.
     * @summary Get Settlements by Order ID
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementsApi
     */
    public static PGOrderFetchSettlement(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SettlementsApiFp().pGOrderFetchSettlement(x_api_version, order_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to create new terminals to use softPOS.
     * @summary Create Terminal
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateTerminalRequest} CreateTerminalRequest Request Body to Create Terminal for SPOS
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposCreateTerminal(x_api_version: string, CreateTerminalRequest: CreateTerminalRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposCreateTerminal(x_api_version, CreateTerminalRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to create a new terminal transaction. To use this API you should first create an order using the Create Order API. Also, you need to enter the terminal details while creating the order and pass the same terminal information while creating a transaction using the below mentioned API.
     * @summary Create Terminal Transaction
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateTerminalTransactionRequest} CreateTerminalTransactionRequest Request body to create a terminal transaction
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposCreateTerminalTransaction(x_api_version: string, CreateTerminalTransactionRequest: CreateTerminalTransactionRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposCreateTerminalTransaction(x_api_version, CreateTerminalTransactionRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to view all details of a terminal.
     * @summary Get Terminal Status using Phone Number
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} terminal_phone_no The terminal for which you want to view the order details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposFetchTerminal(x_api_version: string, terminal_phone_no: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposFetchTerminal(x_api_version, terminal_phone_no, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * You can fetch all the StaticQRs corresponding to given terminal id or phone number. Provide either the terminal_phone_no or terminal_id in the request.
     * @summary Fetch Terminal QR Codes
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} terminal_phone_no Phone number assigned to the terminal. Required if you are not providing the cf_terminal_id in the request.
     * @param {string} cf_terminal_id Cashfree terminal id for which you want to get staticQRs. Required if you are not providing the terminal_phone_number in the request.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposFetchTerminalQRCodes(x_api_version: string, terminal_phone_no: string, cf_terminal_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposFetchTerminalQRCodes(x_api_version, terminal_phone_no, cf_terminal_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to get  terminal transaction.
     * @summary Get Terminal Transaction
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} utr Utr of the transaction.
     * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposFetchTerminalTransaction(x_api_version: string, utr: string, cf_terminal_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposFetchTerminalTransaction(x_api_version, utr, cf_terminal_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to update the terminal details. Email, Phone Number, and Terminal Meta are updatable for \"Storefront\". Only account status change is possible in case of \"Agent\".
     * @summary Update Terminal
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
     * @param {UpdateTerminalRequest} UpdateTerminalRequest Request Body to update terminal for SPOS.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposUpdateTerminal(x_api_version: string, cf_terminal_id: string, UpdateTerminalRequest: UpdateTerminalRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposUpdateTerminal(x_api_version, cf_terminal_id, UpdateTerminalRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to update the terminal status.
     * @summary Update Terminal Status
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
     * @param {UpdateTerminalStatusRequest} UpdateTerminalStatusRequest Request Body to update terminal status for SPOS.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposUpdateTerminalStatus(x_api_version: string, cf_terminal_id: string, UpdateTerminalStatusRequest: UpdateTerminalStatusRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposUpdateTerminalStatus(x_api_version, cf_terminal_id, UpdateTerminalStatusRequest, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to upload the terminal documents.
     * @summary Upload Terminal Docs
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
     * @param {UploadTerminalDocs} UploadTerminalDocs Request Body to update terminal documents for SPOS.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    public static SposUploadTerminalDocs(x_api_version: string, cf_terminal_id: string, UploadTerminalDocs: UploadTerminalDocs, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return SoftPOSApiFp().sposUploadTerminalDocs(x_api_version, cf_terminal_id, UploadTerminalDocs, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
    /**
     * Use this API to delete a saved card instrument for a customer_id and instrument_id
     * @summary Delete Saved Card Instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {string} instrument_id The instrument_id which needs to be deleted
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    public static PGCustomerDeleteInstrument(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return TokenVaultApiFp().pGCustomerDeleteInstrument(x_api_version, customer_id, instrument_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to fetch a single specific saved card for a customer_id by it\'s instrument_id
     * @summary Fetch Specific Saved Card Instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {string} instrument_id The instrument_id of the saved instrument which needs to be queried
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    public static PGCustomerFetchInstrument(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return TokenVaultApiFp().pGCustomerFetchInstrument(x_api_version, customer_id, instrument_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API to fetch saved cards for a customer_id 
     * @summary Fetch All Saved Card Instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {PGCustomerFetchInstrumentsInstrumentTypeEnum} instrument_type Payment mode or type of saved instrument 
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    public static PGCustomerFetchInstruments(x_api_version: string, customer_id: string, instrument_type: PGCustomerFetchInstrumentsInstrumentTypeEnum, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return TokenVaultApiFp().pGCustomerFetchInstruments(x_api_version, customer_id, instrument_type, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }

    /**
     * Use this API To get the card network token, token expiry and cryptogram for a saved card instrument using instrument id
     * @summary Fetch cryptogram for a saved card instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {string} instrument_id The instrument_id of the saved card instrument which needs to be queried
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    public static PGCustomerInstrumentsFetchCryptogram(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig) {
        if(Cashfree.XEnableErrorAnalytics) {
        Sentry.init({
            dsn: 'https://748d9dcfc4286488867c59651cb6121a@o330525.ingest.sentry.io/4506692796350464',
            // Performance Monitoring
            tracesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!
            // Set sampling rate for profiling - this is relative to tracesSampleRate
            profilesSampleRate: 1.0, // Capture 100% of the transactions, reduce in production!,
            attachStacktrace: true,
            enableTracing: true,
            beforeSend: (event) => {
                delete event.contexts.os;
                delete event.contexts.device;
                delete event.server_name;
                if (event.exception && event.exception.values && event.exception.values.length && event.exception.values[0].stacktrace) {
                            const stackTrace = event.exception.values[0].stacktrace;
                            if (stackTrace && stackTrace.frames) {
                                
								const filteredDomains = stackTrace.frames.filter((x) => x.filename.includes("cashfree-pg")).map((x) => x.filename);
                                if (filteredDomains && filteredDomains.length > 0 && filteredDomains[0].includes("cashfree-pg")) {
                                    if(Cashfree.XEnableErrorAnalytics) {
                                        return event;
                                    }
                                    return null;
                                } 
                            }
                        }
						return null;
            },
            });
            Sentry.configureScope((scope) => {
                if(Cashfree.XEnvironment == CFEnvironment.SANDBOX) {
                    scope.setExtra('environment', 'sandbox');
                } else {
                    scope.setExtra('environment', 'production');
                }
                scope.setExtra('release', "4.1.2");
            });
        }
        try {
            return TokenVaultApiFp().pGCustomerInstrumentsFetchCryptogram(x_api_version, customer_id, instrument_id, x_request_id, x_idempotency_key, options).then((request) => request(Cashfree.axios, Cashfree.basePath));
        } catch (error) {
            if(Cashfree.XEnableErrorAnalytics) {
                Sentry.captureException(error);
            }
            throw error;
        }
    }
    
}